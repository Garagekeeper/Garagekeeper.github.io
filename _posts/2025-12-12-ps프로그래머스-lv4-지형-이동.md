---
title: "[PS][프로그래머스-lv4] 지형 이동"
date: 2025-12-12 20:35:08 +0900
description: ""
categories: [Computer Science, Algorithm] #[upper, lower]
tags: [cpp, ps, algorithm, bfs] #must be lower
math: true
mermaid: true
---



[지형 이동](https://school.programmers.co.kr/learn/courses/30/lessons/62050?language=cpp)
### 1) 문제
> **문제 설명**
N x N 크기인 정사각 격자 형태의 지형이 있습니다. 각 격자 칸은 1 x 1 크기이며, 숫자가 하나씩 적혀있습니다. 격자 칸에 적힌 숫자는 그 칸의 높이를 나타냅니다.
>
이 지형의 아무 칸에서나 출발해 모든 칸을 방문하는 탐험을 떠나려 합니다. 칸을 이동할 때는 상, 하, 좌, 우로 한 칸씩 이동할 수 있는데, 현재 칸과 이동하려는 칸의 높이 차가 height 이하여야 합니다. 높이 차가 height 보다 많이 나는 경우에는 사다리를 설치해서 이동할 수 있습니다. 이때, 사다리를 설치하는데 두 격자 칸의 높이차만큼 비용이 듭니다. 따라서, 최대한 적은 비용이 들도록 사다리를 설치해서 모든 칸으로 이동 가능하도록 해야 합니다. 설치할 수 있는 사다리 개수에 제한은 없으며, 설치한 사다리는 철거하지 않습니다.
>
각 격자칸의 높이가 담긴 2차원 배열 land와 이동 가능한 최대 높이차 height가 매개변수로 주어질 때, 모든 칸을 방문하기 위해 필요한 사다리 설치 비용의 최솟값을 return 하도록 solution 함수를 완성해주세요.
>
**제한 사항**
land는 N x N크기인 2차원 배열입니다.
land의 최소 크기는 4 x 4, 최대 크기는 300 x 300입니다.
land의 원소는 각 격자 칸의 높이를 나타냅니다.
격자 칸의 높이는 1 이상 10,000 이하인 자연수입니다.
height는 1 이상 10,000 이하인 자연수입니다.
>
**입출력 예**
>
and	height	result
[[1, 4, 8, 10], [5, 5, 5, 5], [10, 10, 10, 10], [10, 10, 10, 20]]	3	15
[[10, 11, 10, 11], [2, 21, 20, 10], [1, 20, 21, 11], [2, 1, 2, 1]]	1	18

<br>

### 2) 문제 분석 및 풀이
#### 1) 설계, 분석
* 내가 도전했던 풀이
  * BFS를 통해서 구역을 나눔
  * 구역간의 이동가능한 경로중 최솟값을 가진 경로 기록
  * 최소 경로 찾기 <- 여기서 실패
    * 0->1, 0->2 같은 경우를 제대로 처리하지 못함
* 실제 풀이
  * 우선순위 큐를 이용한 BFS 사용
  * 현재까지 오면서 사용한 사다리 비용이 최소인 Cell이 맨 위로 오도록

#### 2) 풀이

``` cpp
#include <vector>
#include <queue>
#include <algorithm>
#include <iostream>

using namespace std;

vector<vector<bool>> visited;

struct Cell
{
    Cell(int x, int y): _x(x), _y(y), _heightDiff(0) {}
    Cell(int x, int y, int heightDiff): _x(x), _y(y), _heightDiff(heightDiff) {}
    int _x;
    int _y;
    //현재까지 오면서 사용한 사다리 비용
    int _heightDiff;
    
    bool operator<(const Cell& other) const
    {
        return _heightDiff > other._heightDiff;
    }
};

bool canGo(int x, int y, int n)
{
    if (x < 0 || x >= n) return false;
    if (y < 0 || y >= n) return false;
    if (visited[x][y]) return false;
    
    return true;
    
}

int BFS(vector<vector<int>>& land, const int& height)
{
    priority_queue<Cell> pq;
    visited.resize(land.size(), vector<bool>(land.size(), false));
    int totalCost = 0;
    
    pq.push(Cell(0,0));
    
    while(!pq.empty())
    {
        Cell top = pq.top();
        pq.pop();
        int cx = top._x;
        int cy = top._y;
        
        if (visited[cx][cy]) continue;
        
        visited[cx][cy] = true;
        totalCost+= top._heightDiff;
        
        vector<int> dx = {0, 1,  0, -1};
        vector<int> dy = {1, 0, -1,  0};
        
        for (int i=0; i<4; i++)
        {
            int nx = cx + dx[i];
            int ny = cy + dy[i];
            if (canGo(nx, ny, land.size()))
            {
                int diff = abs(land[cx][cy]-land[nx][ny]);
                if ( diff > height)
                    pq.push(Cell(nx, ny, diff));
                    
                else
                    pq.push(Cell(nx, ny, 0));
            }
        }
    }
    return totalCost;
}

int solution(vector<vector<int>> land, int height) {
    return BFS(land, height);
}
```