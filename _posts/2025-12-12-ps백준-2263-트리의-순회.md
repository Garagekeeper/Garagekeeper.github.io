---
title: "[PS][백준 2263] 트리의 순회"
date: 2025-12-12 20:13:50 +0900
description: ""
categories: [Computer Science, Algorithm] #[upper, lower]
tags: [cpp, ps, algorithm, tree] #must be lower
math: true
mermaid: true
---



[트리의 순회 (2263)](https://www.acmicpc.net/problem/2263)
### 1) 문제
> **문제 설명**
n개의 정점을 갖는 이진 트리의 정점에 1부터 n까지의 번호가 중복 없이 매겨져 있다. 이와 같은 이진 트리의 인오더와 포스트오더가 주어졌을 때, 프리오더를 구하는 프로그램을 작성하시오.
>
**입력**
첫째 줄에 n(1 ≤ n ≤ 100,000)이 주어진다. 다음 줄에는 인오더를 나타내는 n개의 자연수가 주어지고, 그 다음 줄에는 같은 식으로 포스트오더가 주어진다.
>
**출력**
>
첫째 줄에 프리오더를 출력한다.

<br>

### 2) 문제 분석 및 풀이
#### 1) 설계, 분석
중위 순회와 후위 순회의 성질을 알면 풀리는 문제
후위 순회의 마지막은 루트 노드
중위 순회는 루트 노드를 찾으면 서브 트리를 분리 할 수 있음
#### 2) 풀이
``` cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

using namespace std;

vector<int> inorder;
vector<int> postorder;

void solution(int in_left, int in_right, int post_left, int post_right)
{
    int l1,r1;
    int l2,r2;
    if (in_left > in_right) return;
    if (post_left > post_right) return;

    cout << postorder[post_right] << " ";

    int index = distance(inorder.begin(), find(inorder.begin(), inorder.end(), postorder[post_right]));
    int leftSize= index - in_left;

    solution(in_left, index - 1, post_left, post_left + leftSize - 1 );
    solution(index + 1, in_right, post_left + leftSize, post_right - 1);
    return;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N;
    cin >> N;
    >
    for (int i = 0; i < N ; i++)
    {
        int temp;
        cin >> temp;
        inorder.push_back(temp);
    }

    for (int i = 0; i < N ; i++)
    {
        int temp;
        cin >> temp;
        postorder.push_back(temp);
    }

    solution(0,inorder.size() - 1, 0, postorder.size() - 1);
    return 0;
}
  ```
  
<br>