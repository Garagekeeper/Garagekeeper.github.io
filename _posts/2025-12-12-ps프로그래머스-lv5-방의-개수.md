---
title: "[PS][프로그래머스-lv5] 방의 개수"
date: 2025-12-12 21:19:12 +0900
description: ""
categories: [Computer Science, Algorithm] #[upper, lower]
tags: [cpp, ps, algorithm, graph] #must be lower
math: true
mermaid: true
---

[방의 개수](https://school.programmers.co.kr/learn/courses/30/lessons/49190?language=cpp)
### 1) 문제

> **문제 설명**
![](https://velog.velcdn.com/images/garage_keeper/post/89eeed24-cf23-4963-acec-3219b085c1d4/image.png)
>
**제한 사항**
배열 arrows의 크기는 1 이상 100,000 이하 입니다.
arrows의 원소는 0 이상 7 이하 입니다.
방은 다른 방으로 둘러 싸여질 수 있습니다.
>
**입출력 예**
>
arrows	return
[6, 6, 6, 4, 4, 4, 2, 2, 2, 0, 0, 0, 1, 6, 5, 5, 3, 6, 0]	3
>

<br>


### 2) 문제 분석 및 풀이
#### 1) 설계, 분석
탐색시 경로가 상태를 저장하게 해야하는 문제
#### 2) 풀이
>``` cpp
#include <string>
#include <vector>
#include <set>
#include <algorithm>
#include <map>
using namespace std;
>
map<pair<int,int>, vector<bool>> visited;
int dy[] = {-1,-1,0,1,1,1,0,-1};
int dx[] = {0,1,1,1,0,-1,-1,-1};
>
int solution(vector<int> arrows) {
    int answer = 0;
    >
    int cx = 0;
    int cy = 0;
    int cdir = 0;
    visited[{cx, cy}].resize(8,false);
    for (auto& dir : arrows)
    {
        for (int i=0; i< 2; i++)
        {
            int nx = cx + dx[dir];
            int ny = cy + dy[dir];
            if (visited.find({nx, ny}) == visited.end())
            {
                visited[{nx, ny}].resize(8,false);
            }
            else
            {
                if (visited[{nx, ny}][dir] == false)
                    answer++;
            }
            visited[{nx, ny}][dir] = true;
            visited[{cx, cy}][(dir+4)%8] = true;
            cx = nx;
            cy = ny;
        }
    }
    return answer;
}
 >```

  
<br>