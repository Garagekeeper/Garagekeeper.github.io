---
title: "[PS][프로그래머스-lv3] 가장 먼 노드"
date: 2025-12-12 21:18:00 +0900
description: ""
categories: [Computer Science, Algorithm] #[upper, lower]
tags: [cpp, ps, algorithm, bfs, dijkstra] #must be lower
math: true
mermaid: true
---

## 2. [가장 먼 노드](https://school.programmers.co.kr/learn/courses/30/lessons/49189?language=cpp)
### 1) 문제
>**문제 설명**
  > n개의 노드가 있는 그래프가 있습니다. 각 노드는 1부터 n까지 번호가 적혀있습니다. 1번 노드에서 가장 멀리 떨어진 노드의 갯수를 구하려고 합니다. 가장 멀리 떨어진 노드란 최단경로로 이동했을 때 간선의 개수가 가장 많은 노드들을 의미합니다.
>
노드의 개수 n, 간선에 대한 정보가 담긴 2차원 배열 vertex가 매개변수로 주어질 때, 1번 노드로부터 가장 멀리 떨어진 노드가 몇 개인지를 return 하도록 solution 함수를 작성해주세요.
  >
  **제한사항**
노드의 개수 n은 2 이상 20,000 이하입니다.
간선은 양방향이며 총 1개 이상 50,000개 이하의 간선이 있습니다.
vertex 배열 각 행 [a, b]는 a번 노드와 b번 노드 사이에 간선이 있다는 의미입니다.
  >
  **입출력 예**
n	vertex	return
6	[[3, 6], [4, 3], [3, 2], [1, 3], [1, 2], [2, 4], [5, 2]]	3

<br>

### 2) 문제 분석 및 풀이
#### 1) 설계, 분석
BFS로 풀어도 되지만 다익스트라도 연습할 겸 2가지 방법으로 풀이
(다익스트라 사용함)
#### 2) 풀이
>``` cpp
#include <string>
#include <vector>
#include <queue>
#include <climits>
#include <unordered_map>
using namespace std;
>
unordered_map<int, vector<int>> adjList;
vector<bool> visited;
vector<int> cnt;
int N;
void BFS(int start)
{
    visited.resize(N+1, false);
    queue<pair<int,int>> q;
    q.push({0, start});
    visited[start] = true;
    cnt.push_back(0);
    >
    while(!q.empty())
    {
        auto [dist, node] = q.front(); q.pop();
        >
        if (dist > cnt.size() - 1)
        {
            cnt.push_back(1);
        }
        else
        {
            cnt[dist]++;
        }
        >
        for(auto& to : adjList[node])
        {
            if(visited[to]) continue;
            q.push({dist+1,to});
            visited[to] = true;
        }
    }
}
>
int solution(int n, vector<vector<int>> edge) {
    int answer = 0;
    N=n;
    for (auto& e : edge)
    {
        adjList[e[0]].push_back(e[1]);
        adjList[e[1]].push_back(e[0]);
    }
>
    BFS(1);
>
    return answer = cnt[cnt.size()-1];
}
  >```
  
>```cpp
// 다익스트라
#include <string>
#include <vector>
#include <queue>
#include <climits>
#include <unordered_map>
using namespace std;
  >
vector<vector<int>> dijkstraVec;
unordered_map<int, vector<int>> adjList;
vector<bool> visited;
int N;
void Dijkstra(int start)
{
    dijkstraVec.resize(N+1, vector<int>(2,INT_MAX));
    visited.resize(N+1, false);
    dijkstraVec[start][0] = 0;
    dijkstraVec[start][1] = start;
    // dist, node;
    queue<pair<int, int>> q;
    q.push({0,start});
    >
    while(!q.empty())
    {
        auto [dist, currNode] = q.front(); q.pop();
        >
        if (visited[currNode]) continue;
        visited[currNode]= true;
        >
        for (auto& v : adjList[currNode])
        {
            int start2v = dijkstraVec[v][0];
            int start2curr = dijkstraVec[currNode][0];
            int curr2v = 1;
            >
            if (start2v > start2curr + curr2v)
            {
                dijkstraVec[v][0] = start2curr + curr2v;
                dijkstraVec[v][1] = currNode;
                q.push({dijkstraVec[v][0], v});
            }
        }
    }    
}
>
int solution(int n, vector<vector<int>> edge) {
    int answer = 0;
    N=n;
    >
    for (auto& e : edge)
    {
        adjList[e[0]].push_back(e[1]);
        adjList[e[1]].push_back(e[0]);
    }
    >
    Dijkstra(1);
    >
    int maxDist = 0;
    for (int i=1; i < N+1; i++)
    {
        maxDist = max(maxDist, dijkstraVec[i][0]);
    }
    >
    for (int i=1; i < N+1; i++)
    {
        if (dijkstraVec[i][0] == maxDist) answer++;
    }
    return answer;
}
  >```

  
<br>
  
