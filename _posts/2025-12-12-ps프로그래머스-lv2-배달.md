---
title: "[PS][프로그래머스-lv2] 배달"
date: 2025-12-12 21:12:31 +0900
description: ""
categories: [Computer Science, Algorithm] #[upper, lower]
tags: [cpp, ps, algorithm, graph, dijkstra] #must be lower
math: true
mermaid: true
---

[배달](https://school.programmers.co.kr/learn/courses/30/lessons/12978?language=cpp#)
### 1) 문제
> ![](https://velog.velcdn.com/images/garage_keeper/post/6ba103cb-9b3f-4950-90c7-e4262358d2c5/image.png)

<br>

### 2) 문제 분석 및 풀이
#### 1) 설계, 분석
1번 노드에서 각 노드까지 도달하는 최소 비용을 계산하는 문제
(다익스트라 사용함)
#### 2) 풀이
>``` cpp
#include <vector>
#include <unordered_map>
#include <climits>
#include <queue>
>
using namespace std;
>
vector<bool> visited;
// 0: minDist, 1: node right before this
vector<vector<int>> dijkstraVec;
unordered_map<int, vector<pair<int,int>>> adjList;
>
void Dijkstra(int N, int start)
{
    // 초기화
    visited.resize(N+1, false);
    dijkstraVec.resize(N+1, vector<int>(2, INT_MAX));
    // <현재거리, node번호>
    auto cmp = [](const pair<int,int>& a, const pair<int,int>& b){
        return a.first > b.first;
    };
    priority_queue<pair<int, int>, vector<pair<int,int>>, decltype(cmp)> pq(cmp);
    >
    // 1번이 시작노드
    dijkstraVec[start][0] = 0;
    dijkstraVec[start][1] = 1;
    >
    pq.push({0, start});
    >
    while(!pq.empty())
    {
        int nodeNum = pq.top().second;
        int currDist = pq.top().first;
        pq.pop();
        >
        if (visited[nodeNum]) continue;
        visited[nodeNum] = true;
        // start에서 바로 to로 가는것과
        // 중간에 nodeNum 거치는 것 중 작은걸로 갱신
        // u->v와 u->k->v 비교
        for (auto& [to, weight] : adjList[nodeNum])
        {
            //if (visited[to]) continue;
            if (dijkstraVec[to][0] > dijkstraVec[nodeNum][0] + weight)
            {
                dijkstraVec[to][0] = dijkstraVec[nodeNum][0] + weight;
                dijkstraVec[to][1] = nodeNum;
                pq.push({dijkstraVec[to][0], to});
            }
        }
    }
}
>
int solution(int N, vector<vector<int> > road, int K) {
    int answer = 0;
    >
    for (auto& vec : road)
    {
        // 무방향이라 양쪽 다 추가
        adjList[vec[0]].push_back({vec[1], vec[2]});
        adjList[vec[1]].push_back({vec[0], vec[2]});
    }
    >
    Dijkstra(N, 1);
    >
    // 1번 부터 i까지의 비용이 K이하이면 asnwer증가
    for (int i=1; i<N+1; i++)
    {
        if (dijkstraVec[i][0] <= K) answer++;
    }
>
    return answer;
}
  ```
