---
title: "[PS][백준 1005] AMA craft"
date: 2025-12-12 22:37:01 +0900
description: ""
categories: [Computer Science, Algorithm] #[upper, lower]
tags: [cpp, ps, algorithm, dp, topology sort] #must be lower
math: true
mermaid: true
---

[ACM Craft](https://www.acmicpc.net/problem/1005)
### 1) 문제
>**문제 설명**
서기 2012년! 드디어 2년간 수많은 국민들을 기다리게 한 게임 ACM Craft (Association of Construction Manager Craft)가 발매되었다.
>
이 게임은 지금까지 나온 게임들과는 다르게 ACM크래프트는 다이나믹한 게임 진행을 위해 건물을 짓는 순서가 정해져 있지 않다. 즉, 첫 번째 게임과 두 번째 게임이 건물을 짓는 순서가 다를 수도 있다. 매 게임시작 시 건물을 짓는 순서가 주어진다. 또한 모든 건물은 각각 건설을 시작하여 완성이 될 때까지 Delay가 존재한다.
>
프로게이머 최백준은 애인과의 데이트 비용을 마련하기 위해 서강대학교배 ACM크래프트 대회에 참가했다! 최백준은 화려한 컨트롤 실력을 가지고 있기 때문에 모든 경기에서 특정 건물만 짓는다면 무조건 게임에서 이길 수 있다. 그러나 매 게임마다 특정건물을 짓기 위한 순서가 달라지므로 최백준은 좌절하고 있었다. 백준이를 위해 특정건물을 가장 빨리 지을 때까지 걸리는 최소시간을 알아내는 프로그램을 작성해주자.
  >
**입력**
첫째 줄에는 테스트케이스의 개수 T가 주어진다. 각 테스트 케이스는 다음과 같이 주어진다. 첫째 줄에 건물의 개수 N과 건물간의 건설순서 규칙의 총 개수 K이 주어진다. (건물의 번호는 1번부터 N번까지 존재한다) 
>
둘째 줄에는 각 건물당 건설에 걸리는 시간 D1, D2, ..., DN이 공백을 사이로 주어진다. 셋째 줄부터 K+2줄까지 건설순서 X Y가 주어진다. (이는 건물 X를 지은 다음에 건물 Y를 짓는 것이 가능하다는 의미이다) 
>
마지막 줄에는 백준이가 승리하기 위해 건설해야 할 건물의 번호 W가 주어진다.
>
>**출력**
건물 W를 건설완료 하는데 드는 최소 시간을 출력한다. 편의상 건물을 짓는 명령을 내리는 데는 시간이 소요되지 않는다고 가정한다.
>
건설순서는 모든 건물이 건설 가능하도록 주어진다.
<br>


### 2) 문제 분석 및 풀이
#### 1) 설계, 분석
#### 2) 풀이
>```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
>
using namespace std;
>
void solve()
{
    int N, K;
    cin >> N >> K;
>
    vector<int> build_times(N + 1);
    for (int i = 1; i <= N; ++i)
    {
        cin >> build_times[i];
    }
>
    vector<vector<int>> adj(N + 1);
    vector<int> in_degree(N + 1, 0);
>
    for (int i = 0; i < K; ++i)
    {
        int u, v;
        cin >> u >> v;
        adj[u].push_back(v);
        in_degree[v]++;
    }
>
    int W;
    cin >> W;
>
    // dp[i]는 i번 건물을 짓기 시작할 수 있는 시점
    vector<long long> dp(N + 1, 0);
    queue<int> q;
>
    for (int i = 1; i <= N; ++i)
    {
        if (in_degree[i] == 0)
        {
            q.push(i);
            dp[i] = build_times[i];
        }
    }
>
    while (!q.empty())
    {
        int current_node = q.front();
        q.pop();
>
        for (int next_node : adj[current_node])
        {
            dp[next_node] = max(dp[next_node], dp[current_node] + build_times[next_node]);
            >
            in_degree[next_node]--;
            if (in_degree[next_node] == 0)
            {
                q.push(next_node);
            }
        }
    }
    >
    cout << dp[W] << "\n";
}
>
int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    >
    int T;
    cin >> T;
    while (T--)
    {
        solve();
    }
>
    return 0;
}
>```