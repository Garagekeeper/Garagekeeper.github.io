---
title: "[PS][프로그래머스-lv4] 트리 트리오 중간값"
date: 2025-12-12 23:06:08 +0900
description: ""
categories: [Computer Science, Algorithm] #[upper, lower]
tags: [cpp, ps, algorithm, graph, bfs] #must be lower
math: true
mermaid: true
---

[트리 트리오 중간값](https://school.programmers.co.kr/learn/courses/30/lessons/68937)
### 1) 문제
>**문제 설명**
n개의 점으로 이루어진 트리가 있습니다. 이때, 트리 상에서 다음과 같은 것들을 정의합니다.
>
어떤 두 점 사이의 거리는, 두 점을 잇는 경로 상 간선의 개수로 정의합니다.
임의의 3개의 점 a, b, c에 대한 함수 f(a, b, c)의 값을 a와 b 사이의 거리, b와 c 사이의 거리, c와 a 사이의 거리, 3개 값의 중간값으로 정의합니다.
트리의 정점의 개수 n과 트리의 간선을 나타내는 2차원 정수 배열 edges가 매개변수로 주어집니다. 주어진 트리에서 임의의 3개의 점을 뽑아 만들 수 있는 모든 f값 중에서, 제일 큰 값을 구해 return 하도록 solution 함수를 완성해주세요.
  >
>**제한사항**
>* n은 3 이상 250,000 이하입니다.
  * edges의 행의 개수는 n-1 입니다.
  * edges의 각 행은 [v1, v2] 2개의 정수로 이루어져 있으며, 이는 v1번 정점과 v2번 정점 사이에 간선이 있음을 의미합니다.
  * v1, v2는 각각 1 이상 n 이하입니다.
  * v1, v2는 다른 수입니다.
  *  입력으로 주어지는 그래프는 항상 트리입니다.
>
>**입출력 예**
n	edges	result
4	[[1,2],[2,3],[3,4]]	2
5	[[1,5],[2,5],[3,5],[4,5]]	2
>
<br>


### 2) 문제 분석 및 풀이
#### 1) 설계, 분석
#### 2) 풀이
```cpp
#include <vector>
#include <queue>
using namespace std;

// BFS 결과: (가장 먼 거리, 가장 먼 노드 목록)
pair<int, vector<int>> bfs(int start, const vector<vector<int>>& adj, int n) {
    vector<bool> vis(n+1, false);
    queue<pair<int,int>> q;
    q.push({start, 0});
    vis[start] = true;

    while (!q.empty()) {
        auto [u, d] = q.front(); q.pop();
        if (d > maxDist) {
            maxDist = d;
            farthest.clear();
            farthest.push_back(u);
        } else if (d == maxDist) {
            farthest.push_back(u);
        }
        for (int v : adj[u]) {
            if (!vis[v]) {
                vis[v] = true;
                q.push({v, d + 1});
            }
        }
    }
    return {maxDist, farthest};
}

int solution(int n, vector<vector<int>> edges) 
{
    vector<vector<int>> adj(n + 1);
    for (auto& e : edges) 
    {
        adj[e[0]].push_back(e[1]);
        adj[e[1]].push_back(e[0]);
    }

    auto [d1, far1] = bfs(1, adj, n);
    auto [d2, far2] = bfs(far1[0], adj, n);

    if (far2.size() > 1) return d2;  
    auto [d3, far3] = bfs(far2[0], adj, n);
    if (far3.size() > 1) return d3;  
    return d3 - 1;                   
}
```