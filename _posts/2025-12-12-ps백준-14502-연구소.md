---
title: "[PS][백준 14502] 연구소"
date: 2025-12-12 21:47:34 +0900
description: ""
categories: [Computer Science, Algorithm] #[upper, lower]
tags: [cpp, ps, algorithm, bfs, dfs, backtracking] #must be lower
math: true
mermaid: true
---

[연구소](https://www.acmicpc.net/problem/14502)
### 1) 문제
>**문제 설명**
> 인체에 치명적인 바이러스를 연구하던 연구소에서 바이러스가 유출되었다. 다행히 바이러스는 아직 퍼지지 않았고, 바이러스의 확산을 막기 위해서 연구소에 벽을 세우려고 한다.
>
연구소는 크기가 N×M인 직사각형으로 나타낼 수 있으며, 직사각형은 1×1 크기의 정사각형으로 나누어져 있다. 연구소는 빈 칸, 벽으로 이루어져 있으며, 벽은 칸 하나를 가득 차지한다. 
>
일부 칸은 바이러스가 존재하며, 이 바이러스는 상하좌우로 인접한 빈 칸으로 모두 퍼져나갈 수 있다. 새로 세울 수 있는 벽의 개수는 3개이며, 꼭 3개를 세워야 한다.
>
  벽을 3개 세운 뒤, 바이러스가 퍼질 수 없는 곳을 안전 영역이라고 한다. 위의 지도에서 안전 영역의 크기는 27이다.
>
연구소의 지도가 주어졌을 때 얻을 수 있는 안전 영역 크기의 최댓값을 구하는 프로그램을 작성하시오.
>
>**입력**
>첫째 줄에 지도의 세로 크기 N과 가로 크기 M이 주어진다. (3 ≤ N, M ≤ 8)
>
둘째 줄부터 N개의 줄에 지도의 모양이 주어진다. 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 위치이다. 2의 개수는 2보다 크거나 같고, 10보다 작거나 같은 자연수이다.
빈 칸의 개수는 3개 이상이다.
>
>**출력**
>첫째 줄에 얻을 수 있는 안전 영역의 최대 크기를 출력한다.

<br>


### 2) 문제 분석 및 풀이
#### 1) 설계, 분석
#### 2) 풀이
>```cpp
#include <string>
#include <vector>
#include <climits>
#include <algorithm>
#include <iostream>
#include <queue>
using namespace std;
>
struct Cell
{
    int _x;
    int _y;
    int _type;
};
>
int N,M;
int cnt = 0;
int wallCNT = 3;
int answer = INT_MIN;
vector<vector<int>> board;
vector<Cell> virusVec;
vector<Cell> emptyVec;
>
int dx[4] = {0,1,0,-1};
int dy[4] = {1,0,-1,0};
>
bool CanGo(int x, int y, vector<vector<int>>& inboard)
{
    if ( x < 0 || x >= N ) return false;
    if ( y < 0 || y >= M ) return false;
    if ( inboard[x][y] != 0) return false;
>
    return true;
}
>
void runBFS(std::vector<std::vector<int>> boardCopy, int& remainingEmptyCells)
{
    std::queue<Cell> q;
>
    // 모든 초기 바이러스 위치에서 BFS 시작
    for (const auto& virus : virusVec) 
    {
        q.push(virus);
    }
>
    while (!q.empty())
    {
        Cell current = q.front();
        q.pop();
>
        for (int i = 0; i < 4; i++)
        {
            int nx = current._x + dx[i];
            int ny = current._y + dy[i];
>
            // 이동할 수 있는 곳이라면 (빈칸 0인 곳)
            if (CanGo(nx, ny, boardCopy))
            {
                boardCopy[nx][ny] = 2; // 바이러스 감염
                remainingEmptyCells--; // 안전 영역 감소
                q.push({nx, ny});
            }
        }
    }
}
void dfs()
{
    vector<bool> v(emptyVec.size() - wallCNT, false);
	v.insert(v.end(), wallCNT, true);
	do {
        // 빈칸중에서 벽을 세울 3개 뽑기
        vector<Cell> currentCombination;
		for (int i = 0; i < emptyVec.size(); i++) 
        {
			if (v[i]) currentCombination.push_back(emptyVec[i]);
		}
        // 3개 위치에 벽 세우기
        for (int i=0; i<3; i++)
        {
            int x = currentCombination[i]._x;
            int y = currentCombination[i]._y;
            board[x][y] = 1;
            cnt--;
        }
>
        // 각 바이러스에 대해서 bfs하기
        int res = cnt;
        runBFS(board, res);
        answer = max(answer, res);
>
        // 원상복구 하기
        for (int i=0; i<3; i++)
        {
            int x = currentCombination[i]._x;
            int y = currentCombination[i]._y;
            board[x][y] = 0;
            cnt++;
        }
	} while (next_permutation(v.begin(), v.end()));
}
>
int main()
{
    cin >> N >> M;
    board.resize(N,vector<int>(M));
    for (int i=0; i<N;i++)
    {
        for (int j=0; j<M; j++)
        {
            int val;
            cin >> val;
            board[i][j] = val;
            if (val == 2)
                virusVec.push_back({i,j,2});
            else if (val == 0)
            {
                emptyVec.push_back({i,j,0});
                cnt++;
            }
        }
    }
>
    dfs();
>
    cout << answer << "\n";
    return 0;
}
>```
  

<br>