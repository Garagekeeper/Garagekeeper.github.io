---
title: "[PS][백준 12865] 평범한 배낭"
date: 2025-12-12 22:31:42 +0900
description: ""
categories: [Computer Science, Algorithm] #[upper, lower]
tags: [cpp, ps, algorithm, dp, knapsack] #must be lower
math: true
mermaid: true
---

[평범한 배낭](https://www.acmicpc.net/problem/12865)
### 1) 문제
>**문제 설명**
이 문제는 아주 평범한 배낭에 관한 문제이다.
>
한 달 후면 국가의 부름을 받게 되는 준서는 여행을 가려고 한다. 세상과의 단절을 슬퍼하며 최대한 즐기기 위한 여행이기 때문에, 가지고 다닐 배낭 또한 최대한 가치 있게 싸려고 한다.
>
준서가 여행에 필요하다고 생각하는 N개의 물건이 있다. 각 물건은 무게 W와 가치 V를 가지는데, 해당 물건을 배낭에 넣어서 가면 준서가 V만큼 즐길 수 있다. 아직 행군을 해본 적이 없는 준서는 최대 K만큼의 무게만을 넣을 수 있는 배낭만 들고 다닐 수 있다. 준서가 최대한 즐거운 여행을 하기 위해 배낭에 넣을 수 있는 물건들의 가치의 최댓값을 알려주자.
**입력**
첫 줄에 물품의 수 N(1 ≤ N ≤ 100)과 준서가 버틸 수 있는 무게 K(1 ≤ K ≤ 100,000)가 주어진다. 두 번째 줄부터 N개의 줄에 거쳐 각 물건의 무게 W(1 ≤ W ≤ 100,000)와 해당 물건의 가치 V(0 ≤ V ≤ 1,000)가 주어진다.
>
입력으로 주어지는 모든 수는 정수이다.
>
>**출력**
한 줄에 배낭에 넣을 수 있는 물건들의 가치합의 최댓값을 출력한다.
>**제한**
<br>


### 2) 문제 분석 및 풀이
#### 1) 설계, 분석
#### 2) 풀이
>```cpp
#include <string>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
>
int N,K;
int W,V;
>
vector<pair<int,int>> wvPair; 
vector<vector<int>> dp;
>
int main()
{
    cin >> N >> K;
>
    dp.resize(N+1, vector<int>(K+1));
>
    for (int i=0; i<N; i++)
    {
        cin >> W >> V;
        wvPair.push_back({W,V});
    }
>
    //DP[index][maxweight] maxweight까지 사용가능한 상황에서, index번째 물건까지 고려했을떄
    //가능한 최대 가치
    for (int index=1; index<N+1; index++)
    {
        for (int maxweight=1; maxweight<K+1; maxweight++)
        {
            // 현재 남은 무게가 넣으려고 하는 물건의 무게보다 크면
            // (공간이 남으면)
            if (maxweight - wvPair[index - 1].first >= 0)
            {
                // 안 넣은 경우, 넣은 경우 비교해서 큰 거 저장
                dp[index][maxweight] = max(dp[index-1][maxweight], 
                    dp[index - 1][maxweight -  wvPair[index - 1].first] + wvPair[index - 1].second);
            }
            else
            {
                dp[index][maxweight] = dp[index-1][maxweight];
            }
        }
    }
    >
    cout << dp[N][K] << '\n';
>
}
>```
  

<br>