---
title: "[PS][백준 4803] 트리"
date: 2025-12-12 20:44:59 +0900
description: ""
categories: [Computer Science, Algorithm] #[upper, lower]
tags: [cpp, ps, algorithm, union find, tree] #must be lower
math: true
mermaid: true
---

## 3. [트리(4803)](https://www.acmicpc.net/problem/4803)
### 1) 문제
> **문제 설명**
그래프는 정점과 간선으로 이루어져 있다. 두 정점 사이에 경로가 있다면, 두 정점은 연결되어 있다고 한다. 연결 요소는 모든 정점이 서로 연결되어 있는 정점의 부분집합이다. 그래프는 하나 또는 그 이상의 연결 요소로 이루어져 있다.
>
트리는 사이클이 없는 연결 요소이다. 트리에는 여러 성질이 있다. 예를 들어, 트리는 정점이 n개, 간선이 n-1개 있다. 또, 임의의 두 정점에 대해서 경로가 유일하다.
>
그래프가 주어졌을 때, 트리의 개수를 세는 프로그램을 작성하시오.
  >
**입력**
입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스의 첫째 줄에는 n ≤ 500과 m ≤ n(n-1)/2을 만족하는 정점의 개수 n과 간선의 개수 m이 주어진다. 다음 m개의 줄에는 간선을 나타내는 두 개의 정수가 주어진다. 같은 간선은 여러 번 주어지지 않는다. 정점은 1번부터 n번까지 번호가 매겨져 있다. 입력의 마지막 줄에는 0이 두 개 주어진다.
  >
**출력**
>
입력으로 주어진 그래프에 트리가 없다면 "No trees."를, 한 개라면 "There is one tree."를, T개(T > 1)라면 "A forest of T trees."를 테스트 케이스 번호와 함께 출력한다.


<br>

### 2) 문제 분석 및 풀이
#### 1) 설계, 분석
* 사이클의 존재여부를 확인하는 문제
* 유니온 파인드를 통해서 사이클의 여부를 알아내고 추가 작업을 통해 사이클임을 표시
   * 서로 같은 루트를 가지면 양쪽 부모를 모두 0으로 바꿈
* 모든 간선 입력이 끝나면 정점을 순회, 자신의 부모가 자기 자신인 경우 => 자신이 트리의 루트
  * 위 경우를 카운트
#### 2) 풀이

``` cpp
#include <iostream>
#include <vector>

using namespace std;

int n, m;
vector<int> parents;

int Find(int x)
{
    if (parents[x] == x) return x;
    return parents[x] = Find(parents[x]);
}

bool DetermineSameSet(int a, int b)
{
    int A = Find(a);
    int B = Find(b);

    return A == B;
}

void Union(int a, int b)
{
    int A = Find(a);
    int B = Find(b);

    if (A == 0 || B == 0)
    {
        parents[B] = 0;
        parents[A] = 0;
    }
    else if (A != B)
    {
        parents[B] = A;
    }
    else if (A == B)
    {
        parents[B] = 0;
        parents[A] = 0;
    }
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    int caseNum = 1;
    while (true)
    {
        int n, m;
        cin >> n >> m;
        if ((n==0) && (m==0)) break;
        parents.clear();
        parents.resize(n+1);
        for (int i = 0; i < n+1; i++)
        {
            parents[i] = i;
        }
        for (int i = 0; i < m; i++)
        {
            int a, b;
            cin >> a >> b;
            Union(a,b);
        }
        int treecnt = 0;
        for (int i = 1; i < n + 1; i++)
        {
            if (parents[i] == i)
                treecnt++;
        }
        cout << "Case " << caseNum <<": ";
        if (treecnt == 0)
        {
            cout << "No trees.\n";
        }
        else if (treecnt == 1)
        {
            cout << "There is one tree.\n";
        }
        else if (treecnt > 1)
        {
            cout << "A forest of " << treecnt << " trees.\n";
        }
        caseNum++;
    }
}
```
