---
title: "[PS][백준 17472] 다리 만들기 2"
date: 2026-01-14 02:24:01 +0900
description: ""
categories: [Computer Science, Algorithm] #[upper, lower]
tags: [cpp, ps, algorithm, simulation] #must be lower
math: true
mermaid: true
---


### 1) 문제
**문제 설명**<br>
[다리 만들기 2](https://www.acmicpc.net/problem/17472)

**입력**<br>
첫째 줄에 지도의 세로 크기 N과 가로 크기 M이 주어진다. 둘째 줄부터 N개의 줄에 지도의 정보가 주어진다. 각 줄은 M개의 수로 이루어져 있으며, 수는 0 또는 1이다. 0은 바다, 1은 땅을 의미한다.
<br>
**출력**<br>
모든 섬을 연결하는 다리 길이의 최솟값을 출력한다. 모든 섬을 연결하는 것이 불가능하면 -1을 출력한다.
<br>


### 2) 문제 분석 및 풀이
#### 1) 설계, 분석
* 처음생각
  * 섬들을 구분
  * 섬들의 최소 거리 계산
  * 백트래킹을 통해서 시간 계산
* 실제 풀이
  * 섬들을 구분
  * 섬들의 최소 거리 계산
  * 최소 스패닝트리 생성
    * 다리, 도로의 건설을 최솟값으로 -> MST
    * 사이클이 생기면 최소가 아님 -> 트리
    * 그 중에서 최소를 찾기 -> 최소 스패닝 트리

* 시간 복잡도
  $$
  O((NM)^3 + K^2log(K)) 
  $$
  (K는 섬의 수)
<br>
#### 2) 풀이

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <map>
#include <queue>

using namespace std;

constexpr int MAXRC = 11;
constexpr int INF = 87654321;

int N,M;

// 입력용 격자
int inputgrid[MAXRC][MAXRC];
// 섬 구분용 격자
int grid[MAXRC][MAXRC];
// 섬 인접행렬
int distGrid[MAXRC][MAXRC];
// 방문확인용 격자
bool visited[MAXRC][MAXRC];

int islandNum = 1;
int ans=0;

int mask=0;
int fullmask=0;
int selected = 1;

// 방향용 enum
enum EDir{ R = 0, D, L, U};

int dx[4] = {1,0,-1,0};
int dy[4] = {0,1,0,-1};

// 다른 섬을 찾을 때 사용할 노드들
map<int,vector<pair<int,int>>> islandBoundaries;

// BFS시 방문 가능여부 반환
bool CanGo(int x, int y)
{
    if (x < 1 || x > N) return false;
    if (y < 1 || y > M) return false;
    if (visited[x][y]) return false;
    if (inputgrid[x][y] == 0) return false;
    return true;
}

// 섬의 가장자리인지 확인
bool BoundaryCheck(pair<int, int> pos)
{
    auto [x, y] = pos;

    for (int i=0; i<4; i++)
    {
        int nx = x + dx[i];
        int ny = y + dy[i];
        if (nx < 1 || nx > N) continue;
        if (ny < 1 || ny > M) continue;
        if (inputgrid[nx][ny] == 0) return true;
    }

    return false;
}

// BFS로 섬을 탐색하고 가장자리들을 반환
vector<pair<int,int>> BFS(pair<int, int> start)
{
    queue<pair<int,int>> q;
    vector<pair<int,int>> boundary;

    visited[start.first][start.second] = true;
    grid[start.first][start.second] = islandNum;
    q.push(start);

    if (BoundaryCheck(start))
        boundary.push_back(start);

    while(!q.empty())
    {
        auto [x, y] = q.front(); q.pop();

        for (int i=0; i<4; i++)
        {
            int nx = x + dx[i];
            int ny = y + dy[i];
            
            if (!CanGo(nx, ny)) continue;

            // 방문처리 및 섬번호 기록
            visited[nx][ny] = true;
            grid[nx][ny] = islandNum;
            q.push({nx, ny});

            // 가장자리 확인 후 추가
            if (BoundaryCheck({nx, ny}))
                boundary.push_back({nx,ny});
        }
    }
    return boundary;
}

// islandNum번 섬의 가장자리 정보를 저장
void AddIslandBoundary(vector<pair<int,int>> vec)
{
    islandBoundaries[islandNum] = vec;
}

// 맨해탄 거리 반환 (조건에 따라서 x 혹은 y값만 살아남음)
int GetMahattanDistance(pair<int,int> A, pair<int,int> B)
{
    return (abs(A.first - B.first) + abs(A.second - B.second));
}

// 계산을 간편하게 하기위한 오버라이딩
pair<int,int> operator+(pair<int,int> A, pair<int,int> B)
{
    A.first += B.first;
    A.second += B.second;
    return A;
}


// 섬 사이의 거리 기록
void FillDistance(pair<int,int> origin, pair<int,int> next)
{
    auto [x, y]     = origin;
    auto [nx, ny]   = next;

    int from        = grid[x][y];
    int to          = grid[nx][ny];

    int dist        = GetMahattanDistance(next, origin) - 1;

    // 같은 섬이 아니고, 거리가 2이상인 경우에 거리 갱신
    if (from != to && dist >= 2)
    {
        distGrid[from][to] = min(distGrid[from][to], dist);               
        distGrid[to][from] = min(distGrid[to][from], dist);               
    }
}

pair<int, int> DirToVec(EDir dir)
{
    switch (dir)
    {
        case EDir::R:   return { 0,  1 };
        case EDir::D:   return { 1,  0 };
        case EDir::L:   return { 0, -1 };
        case EDir::U:   return { -1, 0 };
        default:        return { 0,  0 };
    }
}

// 가장자리에서 다른 섬을 탐색
void SearchIsland(pair<int,int> pos, EDir dir)
{
    // 방향 지정
    pair<int,int> addVec = DirToVec(dir);
    pair<int,int> next = pos;

    while(true)
    {
        // 지정 방향으로 이동
        next = next + addVec;
        auto [x, y] = next;

        // 경계 체크
        if (x < 1 || x > N) break;
        if (y < 1 || y > M) break;

        // 해당 지점이 땅이면 거리 채우기
        if (grid[x][y] != 0)
        {
            FillDistance(pos, next); 
            break;               
        }
    }
}

// 정답 계산
void CalcAnswer()
{
    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;

    // 모든 섬을 방문했는지 확인하기 위한 full masking
    for (int i=1; i<islandNum; i++)
        fullmask |= 1 << i;

    // 첫번째 섬 방문처리
    mask |= 1 << selected;

    // prim을 통해서 최소간선트리 생성
    while(mask != fullmask)
    {
        for (int i=1; i<islandNum; i++)
        {
            // i번 섬방문여부 확인, 경로 확인 후 후보군에 간선 추가
            if (!(mask & 1 << i) && distGrid[selected][i] < INF)
                q.push({distGrid[selected][i], i});
        }

        if (q.empty()) return; 

        while (!q.empty())
        {
            // 현재 후보 중 최소 간선을 가져옴
            auto top = q.top(); q.pop();
            // 방문한 적 없는 간선
            if (!(mask & 1 << top.second))
            {
                // 방문처리
                mask |= 1 << top.second;
                // 길이 추가
                ans += top.first;
                // 다음으로 간선을 추가할 기준 노드
                selected = top.second;
                break;
            }
        }
    }
}

void PrintAnswer()
{
    // 길이가 0인 경우도 있어서 MST 생성불가시 -1반환
    if (mask != fullmask)
        cout << -1;
    else
        cout << ans << '\n';
}

void GetInput()
{
    cin >> N >> M;

    for (int i=1; i<=N; i++)
        for (int j=1; j<=M; j++)
            cin >> inputgrid[i][j];
}

// 섬들에 번호를 붙여줌.
void SetIsland()
{
    for (int i=1; i<=N; i++)
        for (int j=1; j<=M; j++)
            if (grid[i][j] == 0 && inputgrid[i][j] == 1)
            {
                AddIslandBoundary(BFS({i,j}));
                islandNum++;
            }
    
    // 섬들의 인접행렬 초기화
    for (int i=1; i<islandNum; i++)
        for (int j=1; j<islandNum; j++)
            distGrid[i][j] = INF;
}

// 섬 사이의 거리 계산
void CalcDistBetweenIsland()
{
    for (int i=1; i<islandNum; i++)
    {
        for (auto pos : islandBoundaries[i])
        {
            SearchIsland(pos, EDir::R);
            SearchIsland(pos, EDir::D);
            SearchIsland(pos, EDir::L);
            SearchIsland(pos, EDir::U);   
        }
    }
}

int main()
{
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    
    GetInput();
    SetIsland();
    CalcDistBetweenIsland();
    CalcAnswer();
    PrintAnswer();
    
    return 0;
}
```
