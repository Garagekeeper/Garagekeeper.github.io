---
title: "[PS][프로그래머스-lv2] 거리두기 확인하기"
date: 2025-12-12 23:03:16 +0900
description: ""
categories: [Computer Science, Algorithm] #[upper, lower]
tags: [cpp, ps, algorithm, simulation] #must be lower
math: true
mermaid: true
---

[거리두기 확인하기](https://school.programmers.co.kr/learn/courses/30/lessons/81302#)
### 1) 문제
>개발자를 희망하는 죠르디가 카카오에 면접을 보러 왔습니다.
>
코로나 바이러스 감염 예방을 위해 응시자들은 거리를 둬서 대기를 해야하는데 개발 직군 면접인 만큼
아래와 같은 규칙으로 대기실에 거리를 두고 앉도록 안내하고 있습니다.
>
대기실은 5개이며, 각 대기실은 5x5 크기입니다.
거리두기를 위하여 응시자들 끼리는 맨해튼 거리1가 2 이하로 앉지 말아 주세요.
단 응시자가 앉아있는 자리 사이가 파티션으로 막혀 있을 경우에는 허용합니다.
>5개의 대기실을 본 죠르디는 각 대기실에서 응시자들이 거리두기를 잘 기키고 있는지 알고 싶어졌습니다. 자리에 앉아있는 응시자들의 정보와 대기실 구조를 대기실별로 담은 2차원 문자열 배열 places가 매개변수로 주어집니다. 각 대기실별로 거리두기를 지키고 있으면 1을, 한 명이라도 지키지 않고 있으면 0을 배열에 담아 return 하도록 solution 함수를 완성해 주세요.

<br>


### 2) 문제 분석 및 풀이
#### 1) 설계, 분석
$N<=5$ 이므로 $O(N!)$까지 가능. 상당히 많은 연산을 필요로 할지도..

* 격자 배열을 순회
  * 현재 위치가 P
    * 오른쪽 2칸 확인
      * 1칸 거리에 칸막이가 있으거나 사람이 없으면 만족
      * 2칸 거리에 사람이 없으면 만족
    * 아래쪽 2칸 확인
      * 1칸 거리에 칸막이가 있으거나 사람이 없으면 만족
      * 2칸 거리에 사람이 없으면 만족
    * 우하단 대각 확인
      * 현재칸 기준 오른쪽, 아래쪽 칸막이 있으면 만족
      * 우하단 칸에 사람이 있으면 만족
    * 우상단 대각 확인
      * 현재칸 기준 오른쪽 위쪽 칸막이 있으면 만족
      * 우상단 칸에 사람이 있으면 만족
  
$O(N^3)$
#### 2) 풀이
```cpp
#include <string>
#include <vector>
#include <iostream>
using namespace std;

vector<int> answer;

// r, rr, d, dd, dr, ru
int dx[6] = {0,0,1,2,1,-1};
int dy[6] = {1,2,0,0,1,1};

bool PosCheck(int nx, int ny)
{
    if (0 > nx || nx >= 5) return false;
    if (0 > ny || ny >= 5) return false;
    return true;
}

void simulate(vector<string> place)
{
    for (int i=0; i<5; i++)
    {
        for (int j=0; j<5; j++)
        {
            if (place[i][j] == 'P')
            {
                bool flag = true;
                int nx;
                int ny;
                
                // 오른쪽
                for (int k=0; k<2; k++)
                {
                    nx = i+dx[k];
                    ny = j+dy[k];
                    if(!PosCheck(nx, ny)) break;
                    if (place[nx][ny] == 'X') break;
                    if (place[nx][ny] == 'P') flag = false;
                }
                
                // 아래쪽
                for (int k=2; k<4; k++)
                {
                    nx = i+dx[k];
                    ny = j+dy[k];
                    if(!PosCheck(nx, ny)) break;
                    if (place[nx][ny] == 'X') break;
                    if (place[nx][ny] == 'P') flag = false;
                }
                

                // 우하단
                nx = i+dx[4];
                ny = j+dy[4];
                if(PosCheck(nx, ny))
                {
                    if (place[nx][ny] == 'P' && !(place[nx-1][ny] == 'X' && place[nx][ny-1] == 'X')) flag = false;
                }

                
                // 우상단
                nx = i+dx[5];
                ny = j+dy[5];
                if(PosCheck(nx, ny))
                {
                     if (place[nx][ny] == 'P' && !(place[nx+1][ny] == 'X' && place[nx][ny-1] == 'X')) flag = false;
                }
                
                if (flag == false) { answer.push_back(0); return;}
            }
        }
    }
    answer.push_back(1);
}


vector<int> solution(vector<vector<string>> places) 
{
    for (auto& place : places)
        simulate(place);
    return answer;
}
```