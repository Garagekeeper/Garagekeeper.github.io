---
title: "[PS][프로그래머스-lv2] 쿼드압축 후 개수 세기"
date: 2025-12-12 23:07:46 +0900
description: ""
categories: [Computer Science, Algorithm] #[upper, lower]
tags: [cpp, ps, algorithm, dfs] #must be lower
math: true
mermaid: true
---

[쿼드압축 후 개수 세기](https://school.programmers.co.kr/learn/courses/30/lessons/68936)
### 1) 문제
>![](https://velog.velcdn.com/images/garage_keeper/post/2ab76450-5dc1-4ba1-81eb-a4d8400610b8/image.png)
![](https://velog.velcdn.com/images/garage_keeper/post/73059545-e610-4481-a9e5-eb5fa719143a/image.png)
<br>


### 2) 문제 분석 및 풀이
#### 1) 설계, 분석
$N \le 1024$ 이므로 $O(N^3)$ 이하의 알고리즘으로 해결 해야함

* 재귀 기반의 DFS로 해결
* 현재 정사각형 격자의 합을 구한다.
  * 합이 0 -> 0으로 압축
  * 합이 정사각형의 넓이 -> 1로 압축
  * 이외의 경우 구역을 4개로 나누고 각 구역마다 같은 과정 반복

$O(N^2logN)$
2차원 배열의 prifix sum을 구하면 $O(N^2)$까지 최적화 가능
#### 2) 풀이
```cpp
#include <string>
#include <vector>

using namespace std;

vector<int> answer(2);

void QuadTreeCompression(int x, int y, int len, vector<vector<int>>& arr)
{
    int sum = 0;
    for (int i=x; i<x+len; i++)
    {
        for (int j=y; j<y+len; j++)
        {
            sum+=arr[i][j];
        }
    }
    
    if (sum == 0) 
    {
        answer[0]++;
        return;
    }
    
    if (sum == len * len) 
    {
        answer[1]++;
        return;
    }
    
    QuadTreeCompression(x ,y ,len/2, arr);
    QuadTreeCompression(x + len/2, y, len/2, arr);
    QuadTreeCompression(x, y+len/2, len/2, arr);
    QuadTreeCompression(x+len/2, y+len/2, len/2, arr);
    
}

vector<int> solution(vector<vector<int>> arr) 
{
    QuadTreeCompression(0,0,arr.size(), arr);
    return answer;
}
```
