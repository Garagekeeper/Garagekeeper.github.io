---
title: "[PS][백준 17140] 이차원 배열과 연산"
date: 2025-12-12 20:47:44 +0900
description: ""
categories: [Computer Science, Algorithm] #[upper, lower]
tags: [cpp, ps, algorithm, simulation] #must be lower
math: true
mermaid: true
---

## 4 [이차원 배열과 연산(17140)](https://www.acmicpc.net/problem/17140)
### 1) 문제
> **문제 설명**
크기가 3×3인 배열 A가 있다. 배열의 인덱스는 1부터 시작한다. 1초가 지날때마다 배열에 연산이 적용된다.
>
R 연산: 배열 A의 모든 행에 대해서 정렬을 수행한다. 행의 개수 ≥ 열의 개수인 경우에 적용된다.
C 연산: 배열 A의 모든 열에 대해서 정렬을 수행한다. 행의 개수 < 열의 개수인 경우에 적용된다.
한 행 또는 열에 있는 수를 정렬하려면, 각각의 수가 몇 번 나왔는지 알아야 한다. 그 다음, 수의 등장 횟수가 커지는 순으로, 그러한 것이 여러가지면 수가 커지는 순으로 정렬한다. 그 다음에는 배열 A에 정렬된 결과를 다시 넣어야 한다. 정렬된 결과를 배열에 넣을 때는, 수와 등장 횟수를 모두 넣으며, 순서는 수가 먼저이다.
>
예를 들어, [3, 1, 1]에는 3이 1번, 1가 2번 등장한다. 따라서, 정렬된 결과는 [3, 1, 1, 2]가 된다. 다시 이 배열에는 3이 1번, 1이 2번, 2가 1번 등장한다. 다시 정렬하면 [2, 1, 3, 1, 1, 2]가 된다.
>
정렬된 결과를 배열에 다시 넣으면 행 또는 열의 크기가 달라질 수 있다. R 연산이 적용된 경우에는 가장 큰 행을 기준으로 모든 행의 크기가 변하고, C 연산이 적용된 경우에는 가장 큰 열을 기준으로 모든 열의 크기가 변한다. 행 또는 열의 크기가 커진 곳에는 0이 채워진다. 수를 정렬할 때 0은 무시해야 한다. 예를 들어, [3, 2, 0, 0]을 정렬한 결과는 [3, 2]를 정렬한 결과와 같다.
>
행 또는 열의 크기가 100을 넘어가는 경우에는 처음 100개를 제외한 나머지는 버린다.
>
배열 A에 들어있는 수와 r, c, k가 주어졌을 때, A[r][c]에 들어있는 값이 k가 되기 위한 최소 시간을 구해보자.
  >
**입력**
첫째 줄에 r, c, k가 주어진다. (1 ≤ r, c, k ≤ 100)
>
둘째 줄부터 3개의 줄에 배열 A에 들어있는 수가 주어진다. 배열 A에 들어있는 수는 100보다 작거나 같은 자연수이다.
  >
**출력**
>
A[r][c]에 들어있는 값이 k가 되기 위한 연산의 최소 시간을 출력한다. 100초가 지나도 A[r][c] = k가 되지 않으면 -1을 출력한다.


<br>

### 2) 문제 분석 및 풀이
#### 1) 설계, 분석
* 원하는 행, 열에 대해서 각 숫자의 등장 횟수를 센다.
  * (a,n) 형태로 저장 (a가 n개)
  * n기준 오름차순, 동일시 a기준 오름차순으로 정렬
  * a,n 순서로 원래 행, 열에 차례차례 덮어쓰기
  * 혹시나 길이가 줄었으면 0으로 밀기
  
<br>
#### 2) 풀이
<br>

``` cpp
#include <iterator>
#include <iostream>
#include <vector>
#include <unordered_map>
#include <algorithm>

using namespace std;

int r,c,k;
vector<vector<int>> board(100, vector<int>(100,0));

bool cmp(const pair<int,int>& a, const pair<int,int>& b)
{
     if (a.second == b.second)
        return a.first < b.first;
    return a.second < b.second;
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> r >> c >> k;
    int cr = 3;
    int cc = 3;

    int eA, eB, eC;
    for (int i=0; i < 3; i++)
    {
        cin >> eA >> eB >> eC;
        board[i][0] = eA;
        board[i][1] = eB;
        board[i][2] = eC;
    }
    
    int sec = 0;
    while (true)
    {
        if (sec > 100)
        {
            cout << -1 << '\n';
            break;
        }

        if (board[r-1][c-1] == k)
        {
            cout << sec << '\n';
            break;
        }

        unordered_map<int, int> cntMap;
        // R operation
        if (cr >= cc)
        {
           int ccindex = cc;
           int crindex = cr;
           // 현재 행렬을 순회
           for (int i=0; i < crindex; i++)
           {
                cntMap.clear();
                //i번째 행에서 각 숫자가 몇번 나오는지 기록
                for (int j=0; j < ccindex; j++)
                {
                    if (board[i][j] == 0 ) continue;
                    cntMap[board[i][j]]++;
                }
                // 위 정보를 토대로 정렬 (횟수 오름차순, 값 오른차순)
                vector<pair<int,int>> forSort (cntMap.begin(), cntMap.end());
                sort(forSort.begin(), forSort.end(), cmp);

                // 새로운 값으로 교환
                // 1 2 1 -> 2가 1개, 1이 2개 식으로 정렬
                // key value를 차례로 넣으면 됨
                // 2 1 1 2
                int j = 0;
                for (j=0; j < forSort.size() && j < 50 ; j++)
                {
                    board[i][2*j] = forSort[j].first;
                    board[i][2*j + 1] = forSort[j].second;
                }

                // 333 같은 경우 3이 3개 로 길이가 줄어들기 때문에
                // 남은 공간에 0으로 밀어야함
                for (j = forSort.size() * 2; j < ccindex; j++)
                {
                    board[i][j] = 0;
                }

                // 열의 최대값 저정
                cc = max(cc , static_cast<int>(forSort.size()) * 2);
                if (cc > 100) cr = 100;
           }
        }
        // C operation
        // 위의 함수를 단순이 행과 열을 바꿔서 할 뿐 원리는 같음
        else if (cr < cc)
        {
           int ccindex = cc;
           int crindex = cr;
           for (int i=0; i < ccindex; i++)
           {
                cntMap.clear();
                for (int j=0; j < crindex; j++)
                {
                    if (board[j][i] == 0 ) continue;
                    cntMap[board[j][i]]++;
                }
                vector<pair<int,int>> forSort (cntMap.begin(), cntMap.end());
                sort(forSort.begin(), forSort.end(), cmp);

                int j = 0;
                for (j=0; j < forSort.size() && j < 50 ; j++)
                {
                    board[2*j][i] = forSort[j].first;
                    board[2*j + 1][i] = forSort[j].second;
                }

                for (j = forSort.size() * 2; j < ccindex; j++)
                {
                    board[j][i] = 0;
                }

                cr = max(cr , static_cast<int>(forSort.size()) * 2);
                if (cr > 100) cr = 100;
           }
        }
        sec++;
    }
}
```

<br>