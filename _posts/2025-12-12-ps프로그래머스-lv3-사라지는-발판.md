---
title: "[PS][프로그래머스-lv3] 사라지는 발판"
date: 2025-12-12 21:40:15 +0900
description: ""
categories: [Computer Science, Algorithm] #[upper, lower]
tags: [cpp, ps, algorithm, dfs, backtracking] #must be lower
math: true
mermaid: true
---

[사라지는 발판](https://school.programmers.co.kr/learn/courses/30/lessons/92345?language=cpp)
### 1) 문제
>**문제 설명**
> 플레이어 A와 플레이어 B가 서로 게임을 합니다. 당신은 이 게임이 끝날 때까지 양 플레이어가 캐릭터를 몇 번 움직이게 될지 예측하려고 합니다.
>
각 플레이어는 자신의 캐릭터 하나를 보드 위에 올려놓고 게임을 시작합니다. 게임 보드는 1x1 크기 정사각 격자로 이루어져 있으며, 보드 안에는 발판이 있는 부분과 없는 부분이 있습니다. 발판이 있는 곳에만 캐릭터가 서있을 수 있으며, 처음 캐릭터를 올려놓는 곳은 항상 발판이 있는 곳입니다. 캐릭터는 발판이 있는 곳으로만 이동할 수 있으며, 보드 밖으로 이동할 수 없습니다. 밟고 있던 발판은 그 위에 있던 캐릭터가 다른 곳으로 이동하여 다른 발판을 밞음과 동시에 사라집니다. 양 플레이어는 번갈아가며 자기 차례에 자신의 캐릭터를 상하좌우로 인접한 4개의 칸 중에서 발판이 있는 칸으로 옮겨야 합니다.
>
다음과 같은 2가지 상황에서 패자와 승자가 정해지며, 게임이 종료됩니다.
>
움직일 차례인데 캐릭터의 상하좌우 주변 4칸이 모두 발판이 없거나 보드 밖이라서 이동할 수 없는 경우, 해당 차례 플레이어는 패배합니다.
두 캐릭터가 같은 발판 위에 있을 때, 상대 플레이어의 캐릭터가 다른 발판으로 이동하여 자신의 캐릭터가 서있던 발판이 사라지게 되면 패배합니다.
게임은 항상 플레이어 A가 먼저 시작합니다. 양 플레이어는 최적의 플레이를 합니다. 즉, 이길 수 있는 플레이어는 최대한 빨리 승리하도록 플레이하고, 질 수밖에 없는 플레이어는 최대한 오래 버티도록 플레이합니다. '이길 수 있는 플레이어'는 실수만 하지 않는다면 항상 이기는 플레이어를 의미하며, '질 수밖에 없는 플레이어'는 최선을 다해도 상대가 실수하지 않으면 항상 질 수밖에 없는 플레이어를 의미합니다. 최대한 오래 버틴다는 것은 양 플레이어가 캐릭터를 움직이는 횟수를 최대화한다는 것을 의미합니다.
>
게임 보드의 초기 상태를 나타내는 2차원 정수 배열 board와 플레이어 A의 캐릭터 초기 위치를 나타내는 정수 배열 aloc, 플레이어 B의 캐릭터 초기 위치를 나타내는 정수 배열 bloc이 매개변수로 주어집니다. 양 플레이어가 최적의 플레이를 했을 때, 두 캐릭터가 움직인 횟수의 합을 return 하도록 solution 함수를 완성해주세요.
>
>**제한 사항**
>* 1 ≤ board의 세로 길이 ≤ 5
* 1 ≤ board의 가로 길이 ≤ 5
* board의 원소는 0 또는 1입니다.
  * 0은 발판이 없음을, 1은 발판이 있음을 나타냅니다.
  * 게임 보드의 좌측 상단 좌표는 (0, 0), 우측 하단 좌표는 (board의 세로 길이 - 1, board의 가로 길이 - 1)입니다.
* aloc과 bloc은 각각 플레이어 A의 캐릭터와 플레이어 B의 캐릭터 초기 위치를 나타내는 좌표값이며 [r, c] 형태입니다.
  * r은 몇 번째 행인지를 나타냅니다.
  * 0 ≤ r < board의 세로 길이
  * c는 몇 번째 열인지를 나타냅니다.
  * 0 ≤ c < board의 가로 길이
  * 초기 보드의 aloc과 bloc 위치는 항상 발판이 있는 곳입니다.
  * aloc과 bloc이 같을 수 있습니다.
*상대 플레이어의 캐릭터가 있는 칸으로 이동할 수 있습니다.
>
>**입출력 예**
board	aloc	bloc	result
[[1, 1, 1], [1, 1, 1], [1, 1, 1]]	[1, 0]	[1, 2]	5
[[1, 1, 1], [1, 0, 1], [1, 1, 1]]	[1, 0]	[1, 2]	4
[[1, 1, 1, 1, 1]]	[0, 0]	[0, 4]	4
[[1]]	[0, 0]	[0, 0]	0

<br>


### 2) 문제 분석 및 풀이
#### 1) 설계, 분석
갱신하는 조건을 찾는게 어려웠던 문제
#### 2) 풀이
>```cpp
#include <string>
#include <vector>
using namespace std;
>
int dx[4] = {0,1,0,-1};
int dy[4] = {1,0,-1,0};
>
vector<int> Apos;
vector<int> Bpos;
vector<vector<int>> gboard;
int answer = 0;
>
bool CanGo(int x, int y)
{
    if (x < 0 || x >= gboard.size()) return false;
    if (y < 0 || y >= gboard[0].size()) return false;
    if (gboard[x][y] == 0) return false;
    return true;
}
>
int dfs(char turn)
{
    int count = 0;
    vector<int>& player = turn == 'A' ? Apos : Bpos;
    int cx = player[0];
    int cy = player[1];
    if (gboard[cx][cy] == 0) return 0;
       >
    for (int i=0; i<4; i++)
    {
        int nx = cx + dx[i];
        int ny = cy + dy[i];
        if (!CanGo(nx, ny)) continue;
        >
        player[0] = nx;
        player[1] = ny;
        gboard[cx][cy] = 0;
        int res = dfs('A' + 'B' - turn) + 1;
        gboard[cx][cy] = 1;
        player[0] = cx;
        player[1] = cy;
            >
        // A부터 시작.
        // 턴이 2로 나뉘어떨어지면 A가 패배
        // 현재까지의 경로가 패배, 새로운 경로가 승리
        // 바로 갱신
        if (count % 2 == 0 && res % 2 == 1) count = res;
        // 현재까지의 경로가 패배, 새로운 경로도 패배 (어차피 지니까 최대한 오래)
        else if (count % 2 == 0 && res % 2 == 0) count = max (count, res);
        // 현재까지 승리, 새로운 경로도 승리 (최대한 빨리 끝내기)
        else if (count % 2 == 1 && res % 2 == 1) count = min (count, res);
        // 현재까지 승리, 새로운 경로 패배인 경우는 고려 X(현재까지가 게임이 더 빨리 끝나니까)
    }
    return count;
}
>
int solution(vector<vector<int>> board, vector<int> aloc, vector<int> bloc) 
{
    gboard = board;
    Apos = aloc;
    Bpos = bloc;
    answer = dfs('A');
    return answer;
}
>```
  

<br>