---
title: "[PS][프로그래머스-lv3] 코딩 테스트 공부"
date: 2025-12-12 22:58:55 +0900
description: ""
categories: [Computer Science, Algorithm] #[upper, lower]
tags: [cpp, ps, algorithm, dijkstra] #must be lower
math: true
mermaid: true
---

[코딩 테스트 공부](https://school.programmers.co.kr/learn/courses/30/lessons/118668?language=cpp#)
### 1) 문제
>![](https://velog.velcdn.com/images/garage_keeper/post/941f5313-b7c5-4001-b536-83e790c46f29/image.png)


<br>


### 2) 문제 분석 및 풀이
#### 1) 설계, 분석
alp, cop <= 150 이니까 $O(N^3)$ 까지 가능할 듯

* 초기 상태에서 목표까지 가는 최소비용을 구하는 문제 -> 다익스트라 사용
* 다익스트라를 2차원 배열에 적용 dijk[alp][cop] : alp,cop까지 오는데 최소 비용

#### 2) 풀이
```cpp
#include <string>
#include <vector>
#include <algorithm>
#include <queue>
using namespace std;

int solution(int alp, int cop, vector<vector<int>> problems) 
{
    int answer = 0;
    
    int alpMax = alp;
    int copMax = cop;
    
    for (auto& problem : problems)
    {
        alpMax = max(alpMax, problem[0]);
        copMax = max(copMax, problem[1]);
    }
    
    //거리 배열
    vector<vector<int>> dijkDistVec(alpMax+1, vector<int>(copMax+1, 1000));
    //방문 배열
    vector<vector<bool>> visited(alpMax+1, vector<bool>(copMax+1, false));
    
    // 알고리즘 공부, 코딩 공부 삽압.
    problems.push_back({0,0,1,0,1});
    problems.push_back({0,0,0,1,1});

    // 시간이 낮은게 위로오게
    // 코스트가 낮은게 먼저
    priority_queue<vector<int>, vector<vector<int>>, greater<>> pq;
    dijkDistVec[alp][cop] = 0;
    // 시간 알고 코딩
    // 지금 알고력 코딩력까지 도달하는데 걸린 최소 비용
    pq.push({dijkDistVec[alp][cop], alp, cop});
    
    while(!pq.empty())
    {
        auto top = pq.top();
        pq.pop();
        int topAlp = top[1];
        int topCop = top[2];
        int currCost = top[0];
        
        //같은 알고/코딩력인데 누가 방문했다 -> 더 적은 코스트가 있었다.
        //넘어감.
        if (visited[topAlp][topCop]) continue;
        visited[topAlp][topCop] = true;
        
        for (auto& problem : problems)
        {
            // 문제의 요구치 미달 -> 건너뜀
            if (topAlp < problem[0] || topCop < problem[1]) continue;
            // 문제를 풀고 난 후 알고/코딩력
            int nAlp = min(alpMax, topAlp + problem[2]);
            int nCop = min(copMax, topCop + problem[3]);
            
            // 기존 값과 문제를 푼뒤의 값중 작은걸로 갱신하고 queue에 넣기
            dijkDistVec[nAlp][nCop] = min(dijkDistVec[topAlp][topCop] + problem[4], dijkDistVec[nAlp][nCop]);
            pq.push({dijkDistVec[nAlp][nCop], nAlp, nCop});
        }
    }
    
    return dijkDistVec[alpMax][copMax];
}
```