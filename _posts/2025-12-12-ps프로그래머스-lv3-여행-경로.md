---
title: "[PS][프로그래머스-lv3] 여행 경로"
date: 2025-12-12 21:29:43 +0900
description: ""
categories: [Computer Science, Algorithm] #[upper, lower]
tags: [cpp, ps, algorithm, graph, dfs] #must be lower
math: true
mermaid: true
---



[여행 경로](https://school.programmers.co.kr/learn/courses/30/lessons/43164?language=cpp)
### 1) 문제

> **문제 설명**
주어진 항공권을 모두 이용하여 여행경로를 짜려고 합니다. 항상 "ICN" 공항에서 출발합니다.
>
항공권 정보가 담긴 2차원 배열 tickets가 매개변수로 주어질 때, 방문하는 공항 경로를 배열에 담아 return 하도록 solution 함수를 작성해주세요.
>
**제한 사항**
모든 공항은 알파벳 대문자 3글자로 이루어집니다.
주어진 공항 수는 3개 이상 10,000개 이하입니다.
tickets의 각 행 [a, b]는 a 공항에서 b 공항으로 가는 항공권이 있다는 의미입니다.
주어진 항공권은 모두 사용해야 합니다.
만일 가능한 경로가 2개 이상일 경우 알파벳 순서가 앞서는 경로를 return 합니다.
모든 도시를 방문할 수 없는 경우는 주어지지 않습니다.
>
시작 도시와 도착 도시를 연결하는 노선은 하나가 아닐 수 있다.
  >
**출력 **
>
tickets	return
[["ICN", "JFK"], ["HND", "IAD"], ["JFK", "HND"]]	["ICN", "JFK", "HND", "IAD"]
[["ICN", "SFO"], ["ICN", "ATL"], ["SFO", "ATL"], ["ATL", "ICN"], ["ATL","SFO"]]	["ICN", "ATL", "ICN", "SFO", "ATL", "SFO"]
>

<br>


### 2) 문제 분석 및 풀이
#### 1) 설계, 분석
정점을 기준으로 탐색을 하는게 아니라, 티켓을 기준으로 탐색하는 문제
#### 2) 풀이
>``` cpp
#include <string>
#include <vector>
#include <queue>
#include <algorithm>
>
using namespace std;
vector<vector<string>> gtickets;
vector<bool> ticketVisited;
vector<string> answer;
int N;
bool dfs(string start, int depth)
{
    answer.push_back(start);
    if (depth > N) return true;
    for (int i=0; i<N; i++)
    {
        if (start != gtickets[i][0]) continue;
        >
        if (ticketVisited[i]) continue;
        ticketVisited[i] = true;
        >
        bool isdone = dfs(gtickets[i][1], depth+1);
        if (isdone) return true;
        ticketVisited[i] = false;
    }
    answer.pop_back();
    return false;
}
>
vector<string> solution(vector<vector<string>> tickets) {
    sort(tickets.begin(), tickets.end());
    >
    gtickets = tickets;
    N = tickets.size();
    >
    ticketVisited.resize(N,false);
    dfs("ICN", 1);
    return answer;
}
 >```

  
<br>
