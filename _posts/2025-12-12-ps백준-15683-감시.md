---
title: "[PS][백준 15683] 감시"
date: 2025-12-12 21:44:19 +0900
description: ""
categories: [Computer Science, Algorithm] #[upper, lower]
tags: [cpp, ps, algorithm, dfs, backtracking] #must be lower
math: true
mermaid: true
---

[감시](https://www.acmicpc.net/problem/1759)
### 1) 문제
>**문제 설명**
> CCTV는 CCTV를 통과할 수 있다. 아래 예시를 보자.
>
0 0 2 0 3
0 6 0 0 0
0 0 6 6 0
0 0 0 0 0
위와 같은 경우에 2의 방향이 ↕ 3의 방향이 ←와 ↓인 경우 감시받는 영역은 다음과 같다.
>
\# # 2 # 3
0 6 # 0 #
0 0 6 6 #
0 0 0 0 #
사무실의 크기와 상태, 그리고 CCTV의 정보가 주어졌을 때, CCTV의 방향을 적절히 정해서, 사각 지대의 최소 크기를 구하는 프로그램을 작성하시오.
>
>**입력**
>첫째 줄에 사무실의 세로 크기 N과 가로 크기 M이 주어진다. (1 ≤ N, M ≤ 8)
>
둘째 줄부터 N개의 줄에는 사무실 각 칸의 정보가 주어진다. 0은 빈 칸, 6은 벽, 1~5는 CCTV를 나타내고, 문제에서 설명한 CCTV의 종류이다. 
>
CCTV의 최대 개수는 8개를 넘지 않는다.
>
>**출력**
첫째 줄에 사각 지대의 최소 크기를 출력한다.

<br>


### 2) 문제 분석 및 풀이
#### 1) 설계, 분석
#### 2) 풀이
{%raw%}
>```cpp
#include <string>
#include <vector>
#include <climits>
#include <iostream>
using namespace std;
>
struct CCTV
{
    int _x;
    int _y;
    int _type;
    vector<pair<int,int>> rotVec;
};
>
int N,M;
int cnt = 0;
int answer = INT_MAX;
>
vector<CCTV> cctvVec;
vector<vector<int>> board;
vector<int> rotCntVec = {0,4,2,4,4,1};
vector<vector<pair<int,int>>> rotVecs = {
    {},
    {{0, 1}}, 
    {{0, 1}, {0, -1}}, 
    {{0, 1}, {-1, 0}},
    {{0, 1}, {0, -1}, {-1, 0}},
    {{0, 1}, {0, -1}, {-1, 0}, {1, 0}},
};
>
int CalcBlindSpot(int index, vector<vector<int>> inboard)
{
    int res = cnt;
>
    for (int i =0; i < cctvVec.size(); i++)
    {
        auto current_cctv = cctvVec[i];
        for (int j=0; j<current_cctv.rotVec.size(); j++)
        {
            int x = current_cctv._x;
            int y = current_cctv._y;
            while (true)
            {
                int nx = x + current_cctv.rotVec[j].first;
                int ny = y + current_cctv.rotVec[j].second;
>
                if (nx < 0 || nx >= N) break;
                if (ny < 0 || ny >= M) break;
                if (inboard[nx][ny] == 6)break;
                if (inboard[nx][ny] == 0)
                {
                    inboard[nx][ny] = -1;
                    res--;
                }
                >
                x = nx;
                y = ny;
            }
        }
    }
>
    return res;
}
>
void RotateVec(CCTV& ctv, int cnt)
{
    if (cnt == 0) return;
>
    int clockwise = cnt > 0 ? 0 : 1;
>
    for (int i=0; i<abs(cnt); i++)
    {
        for (int j = 0; j < ctv.rotVec.size(); j++)
        {
            int x = ctv.rotVec[j].first;
            int y = ctv.rotVec[j].second;
            if (cnt > 0) 
            {
                // 시계 방향 90도
                ctv.rotVec[j].first = y;
                ctv.rotVec[j].second = -x;
            } 
            else 
            {
                // 반시계 방향 90도
                ctv.rotVec[j].first = -y;
                ctv.rotVec[j].second = x;
            }
        }
    }
}
>
void dfs(int index)
{
    if (index == cctvVec.size())
    {
        int res = CalcBlindSpot(index, board);
        answer = min(res, answer);
        return;
    }
>
    CCTV& ctv = cctvVec[index];
>
    for (int i = 0; i < rotCntVec[ctv._type]; i++)
    {
        RotateVec(ctv, i);
        dfs(index + 1);
        RotateVec(ctv, i * -1);
    }
}
>
int main()
{
    cin >> N >> M;
    board.resize(N, vector<int>(M));
>
    for (int i=0; i<N; i++)
    {
        for (int j=0; j<M; j++)
        {
            int val;
            cin >> val;
            board[i][j] = val;
            if (val == 0) cnt++;
            if (1 <= val && val <= 5) cctvVec.push_back({i,j,val,rotVecs[val]});
        }
    }
>
    dfs(0);
    cout << answer << '\n';
    return 0;
}
>```
{%endraw%}

<br>