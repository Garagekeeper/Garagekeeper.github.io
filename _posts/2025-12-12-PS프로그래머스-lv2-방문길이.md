---
title: "[PS][프로그래머스-lv2] 방문길이"
date: 2025-12-12 19:30:39 +0900
description: ""
categories: [Computer Science, Algorithm] #[upper, lower]
tags: [cpp, ps, algorithm] #must be lower
math: true
mermaid: true
---

## [방문 길이](https://school.programmers.co.kr/learn/courses/30/lessons/49994?language=cpp)
### 1) 문제
  >**문제 설명**
게임 캐릭터를 4가지 명령어를 통해 움직이려 합니다. 명령어는 다음과 같습니다.
U: 위쪽으로 한 칸 가기
D: 아래쪽으로 한 칸 가기
R: 오른쪽으로 한 칸 가기
L: 왼쪽으로 한 칸 가기
>
캐릭터는 좌표평면의 (0, 0) 위치에서 시작합니다. 좌표평면의 경계는 왼쪽 위(-5, 5), 왼쪽 아래(-5, -5), 오른쪽 위(5, 5), 오른쪽 아래(5, -5)로 이루어져 있습니다.
>
>이때, 우리는 게임 캐릭터가 지나간 길 중 캐릭터가 처음 걸어본 길의 길이를 구하려고 합니다. 예를 들어 위의 예시에서 게임 캐릭터가 움직인 길이는 9이지만, 캐릭터가 처음 걸어본 길의 길이는 7이 됩니다. (8, 9번 명령어에서 움직인 길은 2, 3번 명령어에서 이미 거쳐 간 길입니다)
>
단, 좌표평면의 경계를 넘어가는 명령어는 무시합니다.
  >
**제한사항**
dirs는 string형으로 주어지며, 'U', 'D', 'R', 'L' 이외에 문자는 주어지지 않습니다.
dirs의 길이는 500 이하의 자연수입니다.
  >
  
### 2) 풀이
```cpp
#include <string>
#include <vector>
using namespace std;
vector<vector<vector<bool>>> visited;
>
struct Pos
{
    int x;
    int y;
};

// 목표 좌표에 갈 수 있는지
bool CanGo(Pos nPos)
{
    int x = nPos.x;
    int y = nPos.y;
    if (x < -5 || x > 5) return false;
    if (y < -5 || y > 5) return false;
    return true;
}

bool isVisitedBySamePath(Pos bPos, Pos nPos, int dir)
{
    // 벡터 탐색을 위한 인덱스
    int bx, by;
    int nx, ny;
    >
    bx = (bPos.x + 5);
    by = (bPos.y + 5);
    nx = (nPos.x + 5);
    ny = (nPos.y + 5);
    
    //양방향 검사
    //이전 좌표에서 목표 좌표로 방문한 적 있는지
    //목표 좌표에서 이전 좌표로 방문한 적 있는지
    if (visited[by][bx][dir] || visited[ny][nx][(dir + 2)%4]) return true;
    else 
    {
        visited[by][bx][dir] = true;
        return false;
    }
}

void move(char c, Pos& currentpos, int& answer)
{
    Pos nPos = currentpos;
    int dir=0;
    // 목표 좌표 설정
    if (c == 'U')
    {
        nPos.y += 1;
        dir=0;
    }
    else if (c == 'D')
    {
        nPos.y -= 1;
        dir=2;
    }
    else if (c == 'R')
    {
        nPos.x += 1;
        dir=1;
    }
    else if (c == 'L')
    {
        nPos.x -= 1;
        dir=3;
    }
    
    if (CanGo(nPos))
    {
        // 목표 좌표에 갈 수 있으면
        // 이미 방문한 경로인지 확인 아니라면 count 증가
        if (!isVisitedBySamePath(currentpos, nPos, dir)) answer++;
        >
        // 현재 좌표 갱신
        currentpos = nPos;
    }
}

int solution(string dirs) 
{
    int answer = 0;
    //각 좌표에서 갈 수 있는 4가지 경로를 방문 했는지 저장하는 벡터
    visited.resize(11, vector<vector<bool>>(11, vector<bool>(4)));
    
    Pos currentPos = Pos{0,0};
    
    for (auto c : dirs)
    {
        move(c, currentPos ,answer);
    }
    
    return answer;
}
```
  
* visited 벡터를 통해서 해당 좌표에서 어떤 방향으로 방문 했는지 기록.
* 현재 좌표->목표 좌표, 목표 좌표->현재 좌표로 방문 했는지 체크
  * 현재 좌표에서 목표 dir 방향 방문 확인
  * 목표 좌표에서 (dir + 2)%4 방향 (dir과 반대 방향) 방문 확인
    * ex) (1,2) -> (1,3) 혹은 (1,3) -> (1,2) 둘 중 하나라도 있으면 이미 방문한 경로.