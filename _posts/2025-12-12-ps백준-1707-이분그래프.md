---
title: "[PS][백준 1707] 이분그래프"
date: 2025-12-12 19:37:28 +0900
description: ""
categories: [Computer Science, Algorithm] #[upper, lower]
tags: [cpp, ps, algorithm, bfs, bipartite graph] #must be lower
math: true
mermaid: true
---

[이분 그래프](https://www.acmicpc.net/problem/1707)
### 1) 문제
  >
  **문제 설명**
그래프의 정점의 집합을 둘로 분할하여, 각 집합에 속한 정점끼리는 서로 인접하지 않도록 분할할 수 있을 때, 그러한 그래프를 특별히 이분 그래프 (Bipartite Graph) 라 부른다.
>
그래프가 입력으로 주어졌을 때, 이 그래프가 이분 그래프인지 아닌지 판별하는 프로그램을 작성하시오.
>
**입력**
입력은 여러 개의 테스트 케이스로 구성되어 있는데, 첫째 줄에 테스트 케이스의 개수 K가 주어진다. 각 테스트 케이스의 첫째 줄에는 그래프의 정점의 개수 V와 간선의 개수 E가 빈 칸을 사이에 두고 순서대로 주어진다. 각 정점에는 1부터 V까지 차례로 번호가 붙어 있다. 이어서 둘째 줄부터 E개의 줄에 걸쳐 간선에 대한 정보가 주어지는데, 각 줄에 인접한 두 정점의 번호 u, v (u ≠ v)가 빈 칸을 사이에 두고 주어진다. 
  >
**출력**
K개의 줄에 걸쳐 입력으로 주어진 그래프가 이분 그래프이면 YES, 아니면 NO를 순서대로 출력한다.
  >
  
### 2) 풀이
```cpp
#include <algorithm>
#include <iostream>
#include <queue>
#include <stack>
#include <vector>
using namespace std;
#define COLOR_R 1
#define COLOR_B 2

int K, V, E;
vector<vector<int>> graph;
vector<int> visited;

bool BFS(int start)
{
	queue<int> q;
	q.push(start);
	visited[start] = COLOR_R;

	while (true)
	{
		if (q.size() == 0)
			break;
		int front = q.front();
		q.pop();

		for (int i = 0; i < graph[front].size(); i++)
		{
			int v = graph[front][i];
			if (visited[v] == 0)
			{
				if (visited[front] == COLOR_R)
				{
					visited[v] = COLOR_B;
					q.push(v);
				}
				else if (visited[front] == COLOR_B)
				{
					visited[v] = COLOR_R;
					q.push(v);
				}
			}
			else if (visited[v] == visited[front])
			{
				return false;
			}
		}
	}
	return true;
}

bool isBipartite()
{
	bool done = false;
	while (true)
	{
		if (done)
			break;

		for (int i = 1; i <= V; i++)
		{
			if (!visited[i])
			{
				bool res = BFS(i);
				if (!res)
					return false;
				else
					i = 0;
			}
			else
			{
				if (i == V)
					done = true;
			}
		}
	}
	return true;
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	cin >> K;
	for (int i = 0; i < K; i++)
	{
		cin >> V >> E;
		graph.assign(V + 1, vector<int>());
		visited.assign(V + 1, 0);

		for (int j = 0; j < E; j++)
		{
			int from, to;
			cin >> from >> to;
			graph[from].push_back(to);
			graph[to].push_back(from);
		}
		cout << (isBipartite() ? "YES" : "NO") << "\n";
	}
}
```
  
  * 이분 그래프를 알아 볼 수 있었던 문제.
  * 모든 노드를 방문할 때 까지 BFS를 돌려야함
  * BFS
  	* queue에서 뽑은 노드가 갈 수 있는 노드들을 순회
    * 방문하지 않은 경우 뽑은 노드와 다른 색상 정보를 기입
  	* 이미 방문한 경우
  	  * 뽑은 노드와 색이 동일하면 이분 그래프가 아님