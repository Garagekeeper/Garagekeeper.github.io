---
layout: page
title: Portfolio
permalink: /portfolio
---

<link rel="stylesheet" href="/assets/css/portfolio.css" />

<main>
  <div class="project-container">
    <h1 class="ptitle">1. FPS 프레임워크 프로젝트</h1>
    <!-- Overview -->
    <section>
      <h2>프로젝트 개요</h2>
      <p>
        Unity 기반 FPS 싱글 플레이 프로젝트로 Unity3D를 공부및 FPS 프레임워크를
        만들기위한 프로젝트입니다. 유니티에서 제공하는 ScriptableObject, Object
        Pool등을 활용해 뱀서라이크 FPS를 만드는데 집중했습니다.
      </p>
    </section>

    <!-- ref -->
    <section>
      <h2>사용 기술</h2>
      <ul>
        <li>Unity 6.2</li>
        <li>C#</li>
      </ul>
    </section>

    <!-- Roles -->
    <section>
      <h2>담당 역할</h2>
      <ul>
        <li>게임 클라이언트 전반 구조 설계 및 구현</li>
      </ul>
    </section>

    <!-- Video -->
    <section>
      <h2>플레이 영상</h2>
      <div class="video-wrapper">
        <iframe
          width="560"
          height="315"
          src="https://www.youtube.com/embed/g_O869B6rdk"
          title="Gameplay Video"
          allowfullscreen
        >
        </iframe>
      </div>
    </section>

    <!-- Core System -->
    <section>
      <h2>겪었던 문제와 해결 방안</h2>

      <article>
        <div class="Problem1">
          <h3>1. 애니메이션 문제</h3>
          <ul>
            <li>
              <strong>문제</strong>
              <p>
                키프레임 애니메이션만으로는 반동, 조준등 플레이어의 상태에
                따라서 달라지는 움직임을 표현하기 힘들었습니다
              </p>
            </li>

            <li>
              <strong>선택</strong>
              <p>
                키프레임 애니메이션은 유지한 채 런타임에서 계산해 더해주는
                방식을 선택했습니다.
              </p>
            </li>

            <li>
              <strong>결과</strong>
              <ul>
                <li>
                  그 결과 키프레임 애니메이션을 수정하지 않고도 여러 움직임을
                  쉽게 구현및 수정할 수 있었습니다
                </li>
              </ul>
            </li>
          </ul>
          <div>
            <img src="/assets/img/flowchart1.png" alt="flowchart1" />
          </div>
          <br />
          <details class="code-sample">
            <summary>코드 예시 (클릭시 펼쳐짐)</summary>
            <a
              href="https://github.com/Garagekeeper/Guns_GermsAndSteel"
              target="_blank"
              >Full Source(수정 필요)</a
            >
            <br />
            <p><strong>Animator-Target에 적용할 최종 Transform 설정</strong></p>
            <pre><code class="language-csharp">
// ProceduralAnimator.cs
private void UpdateSingleFrame()
{
  if (Time.timeScale &lt;= 0) return;

  // 위치 값 결정
  Vector3 position = DefaultPosition + TargetPosition;
  Quaternion rotation = Quaternion.identity;


  // 위치벡터가 유효하면 위치 이동.
  if (IsVector3Valid(position))
    transform.localPosition = position;
  // 아니면 오류 출력
  else
    Debug.LogError($"Total outputs Nan position. Result animation position will be ignored.", this);

  // 기준 회전과 목표 회전의 값이 유효하면
  if(IsVector3Valid(DefaultRotation) && IsVector3Valid(TargetRotation))
  {
      // 회전값 기록
      rotation = Quaternion.Euler(DefaultRotation + TargetRotation);
  }
  else
  {
    // 아니면 에러
    Debug.LogError($"Total outputs Nan rotation. Result animation rotation will be ignored.", this);
  }

  // 최종 값 또한 유효하면
  if (IsVector3Valid(DefaultRotation + TargetRotation))
      // 기록했던 회전 값 적용
      transform.localRotation = rotation;
}
            </code></pre>
            <br />
            <p><strong>트리거와 애니메이션간의 연결</strong></p>
            <pre><code class="language-csharp">
// ProceduralAnimation.cs의 Tick() 중 일부
// 입력 타입(Hold, Tab, Trigger 등)에 따라 애니메이션 재생/정지를 자동 결정
if (triggerType == InputActionType.Hold)
{
    if (_triggerInputAction is null) return;
    // 버튼을 누르고 있을 때 재생, 놓으면 정지
    //if (_triggerInputAction.IsPressed() &amp;amp;&amp;amp; Progress &amp;lt; 0.9f) Play();
    if (_triggerInputAction.IsPressed()) Play();
    else Stop();
}

// 연결(Connection) 시스템을 통해 상태 간섭 해결
// 지금 이 애니메이션과 연결된 연결의 목록
// 연결은 target과 type 형태로 구성
// 이 애니메이션이 target과 연결됨(type 형태로)
foreach (ProceduralAnimationConnection connection in connections)
{
    // target이 Idle상태(재생X)일때 정지하는 애니메이션이면
    if (connection.type == ProceduralAnimationConnectionType.PauseIfTargetIdle)
    {
        // target이 정지중이면 나도 정지
        if (!connection.target.IsPlaying) Pause();
        else Unpause();
    }

    // 타겟이 재생중이면 정지
    if (connection.type == ProceduralAnimationConnectionType.PauseIfTargetPlaying)
    {
        // 재생중(Trigger)
        if (connection.target.IsPlaying) Pause();
        else Unpause();
    }
}
            </code></pre>
            <br />
            <p><strong>부드러운 보간</strong></p>
            <pre><code class="language-csharp">
// ProceduralAnimation.cs의 UpdateProgress()
private void UpdateProgress()
{
  //TODO 하드코딩 바꾸기
  float masterSpeed = 1;

  if (_isPlaying)
    Progress = Mathf.SmoothDamp(Progress, 1, ref _currentVelocity, length / masterSpeed);

  if (!_isPlaying || HasToAvoid())
    Progress = Mathf.SmoothDamp(Progress, 0, ref _currentVelocity, length / masterSpeed);
}
            </code></pre>
          </details>
        </div>
        <br />
        <div class="Problem2">
          <h3>2. UI 디자인패턴</h3>
          <ul>
            <li>
              <strong>문제</strong>
              <p>
                기존 구조에서는 컨트롤러가 입력 처리, 게임 로직, UI 갱신을
                동시에 담당하면서 클래스가 비대해졌고, UI 수정 시 로직 전반에
                영향을 주는 문제가 발생했습니다. 이에 따라 UI와 게임 로직을
                명확히 분리할 수 있는 구조가 필요하다고 판단했습니다.
              </p>
            </li>

            <li>
              <strong>선택</strong>
              <p>
                여러 UI 아키텍처 중 MVP 패턴을 선택했습니다. View와 로직 분리의
                필요성과 프로젝트 규모를 고려해 MVP가 적합하다고 판단했습니다.
                MVVM의 경우 본 프로젝트의 UI 복잡도에 비해 과하다고 판단하여
                제외했습니다.
              </p>
            </li>

            <li>
              <strong>결과</strong>
              <p>
                UI 관련 로직을 Presenter로 분리함으로써 컨트롤러에서 View를 직접
                수정하거나 Model과 UI가 강하게 결합되는 구조를 개선할 수
                있었습니다. View는 UI 표시에 집중하고, Presenter에서 상태 판단과
                UI 로직을 처리함으로써 구조가 명확해졌습니다. 그 결과, 예를 들어
                탄약 부족 경고 UI가 정상적으로 동작하지 않을 경우 해당 UI의
                Presenter를 중심으로 빠르게 원인을 추적할 수 있어 디버깅과
                유지보수가 수월해졌습니다.
              </p>
            </li>
          </ul>
          <br />
          <details class="code-sample">
            <summary>코드 예시 (클릭시 펼쳐짐)</summary>
            <pre><code class="language-csharp">
public class FirearmHUD : UIBase, IView
{
  [Header("Text")]
  public TextMeshProUGUI firearmNameText;
  public TextMeshProUGUI ammoTypeNameText;
  public TextMeshProUGUI ammoInMagazineText;
  public TextMeshProUGUI ammoInInventoryText;
  public GameObject outOfAmmoAlert;
  public GameObject lowAmmoAlert;
        
  [Header("Colors")]
  public Color normalColor = Color.white;
  public Color alertColor = Color.red;

  // UI 갱신
  public void UpdateAmmoDisplay(int inMagazine, int inInventory, int maxCap, bool isLow)
  {
      // ammo
      ammoInMagazineText.text = inMagazine.ToString();
      ammoInInventoryText.text = inInventory.ToString();
  
      // ammo alert
      outOfAmmoAlert.SetActive(inMagazine &lt;= 0);
      lowAmmoAlert.SetActive(isLow);
      ammoInMagazineText.color = isLow ? alertColor : normalColor;
  }

  // 무기 이름 갱신
  public void UpdateNameDisplay(string firearmName)
  {
      firearmNameText.text = firearmName;
  }
  
  public void Show()
  {
      gameObject.SetActive(true);
  }

  public void Hide()
  {
      gameObject.SetActive(false);
  }
}

            </code></pre>

            <pre><code class="language-csharp">

public class FirearmHUDPresenter : Presenter&lt;FirearmHUD, InventoryCore&gt;
{
  private Firearm _activeFirearm;
  
  public FirearmHUDPresenter(FirearmHUD view, InventoryCore model) : base(view, model)
  {
      
  }
  public override void Init()
  {
      model.OnItemSwapped += HandleWeaponSwap;
  }

  // 무기가 변동되었을 때 이벤트를 통해 호출되는 함수
  private void HandleWeaponSwap(Firearm newFirearm)
  {
      //0. 기존 이벤트 해제
      if (_activeFirearm != null)
          _activeFirearm.OnAmmoChanged -= UpdateAmmoUI;
      
      //1. 새 무기로 교체
      _activeFirearm = newFirear 
      if (_activeFirearm != null)
      {
          //2. 새 무기의 이벤트 구독
          _activeFirearm.OnAmmoChanged += UpdateAmmoUI;
          
          //3. UI갱신
          UpdateAmmoUI(_activeFirearm.AmmoInMagazine, _activeFirearm.ammoItemInInventory.Count, _activeFirearm.fireArmData.magazineCapacity);
          UpdateFirearmNameUI(_activeFirearm.fireArmData.firearmName);
      }
  }
  
  // UI의 장탄수 갱신
  private void UpdateAmmoUI(int mag, int inv, int maxCap)
  {
      var isLow = mag > 0 && mag &lt;= maxCap / 3;
      view.UpdateAmmoDisplay(mag, inv, maxCap, isLow);
  }

  // UI의 무기 이름 갱신
  private void UpdateFirearmNameUI(string firearmName)
  {
      view.UpdateNameDisplay(firearmName);
  }

  public override void Release()
  {
      model.OnItemSwapped -= HandleWeaponSwap;
      if (_activeFirearm != null)
      {
          _activeFirearm.OnAmmoChanged -= UpdateAmmoUI;
          _activeFirearm.OnFirearmNameChanged -= UpdateFirearmNameUI;
      }
  }
}

            </code></pre>

            <pre><code class="language-csharp">
//Firearm.cs
/*-------------------------
 *           Ammo
-------------------------*/
        
/// &lt;summary&gt;
/// 현재 화기에 필요한 탄약 타입 클래스
/// &lt;/summary&gt;
public AmmoType requiredAmmoType;
/// &lt;summary&gt;
/// 실제 가지고 있는 탄약 수
/// num of bullet player has;
/// &lt;/summary&gt;
public AmmoItem ammoItemInInventory;

private int _ammoInMagazine;
public int AmmoInMagazine
{
    get => _ammoInMagazine;
    set
    {
        _ammoInMagazine = value;
        OnAmmoChanged?.Invoke(_ammoInMagazine, ammoItemInInventory.Count, fireArmData.magazineCapacity);
    }
}
            </code></pre>

            <pre><code class="language-csharp">
//InventoryCore.cs
public event Action&lt;Firearm&gt; OnItemSwapped;

// 무기를 변경할 때 사용하는 함수
public void SwapItem(int index)
{
    // 0. 같은 번호면 종료
    if (SelectedIndex == index) return;
    // 1. 이전 무기 끄기
    OffFirearm(SelectedIndex);
    // 2. 인덱스 갱신
    SelectedIndex = index;
    // 3.새 무기 켜기
    OnFirearm(SelecedIndex);
    // 4.swap 이벤트 Invoke
    OnItemSwapped?.Invoke(items[SelectedIndex]);
}
            </code></pre>
            <br />
          </details>
        </div>
        <br />
        <div class="Problem3">
          <h3>3. 데이터 관리 및 풀링</h3>
          <ul>
            <li>
              <strong>문제</strong>
              <p>
                능력과 프리셋과 같은 게임 데이터가 코드와 강하게 결합되어 있어
                수치 조정이나 밸런스 변경 시 코드 수정과 재컴파일이 빈번하게
                발생했습니다. 또한 전투 중 자주 생성·삭제되는 오브젝트를
                효율적으로 관리할 수 있는 구조가 필요했습니다.
              </p>
            </li>

            <li>
              <strong>선택</strong>
              <p>
                이전 프로젝트에서는 CSV 기반 데이터 관리와 Addressables를 통한
                리소스 로딩, 그리고 자체 구현한 풀링 시스템을 사용했지만, 본
                프로젝트에서는 데이터 규모와 개발 흐름을 고려해
                ScriptableObject와 Unity에서 제공하는 Object Pool을
                선택했습니다. 정적 데이터의 비중이 높고 초기 로딩 비용이
                부담되지 않는 구조였기 때문에, 런타임 로딩 복잡도를 줄이고
                에디터 중심의 빠른 반복 개발에 더 적합한 방식을 우선했습니다.
              </p>
            </li>

            <li>
              <strong>결과</strong>
              <ul>
                <li>
                  ScriptableObject를 통해 능력 정보, 수치, 프리셋을 코드 수정
                  없이 에디터에서 관리할 수 있어 수치 조정과 반복 테스트가
                  수월해졌습니다. 또한 동일한 데이터를 여러 코드에서
                  참조하더라도 일관성을 유지할 수 있었습니다.
                </li>
                <li>
                  Unity Object Pool을 적용하여 SFX, Enemy, 경험치 Gem 등 전투 중
                  빈번하게 생성 / 삭제되는 오브젝트를 재사용함으로써, 오브젝트
                  관리 구조를 단순화할 수 있었습니다.
                </li>
              </ul>
            </li>
          </ul>

          <details class="code-sample">
            <summary>코드 예시 (클릭시 펼쳐짐)</summary>
            <pre><code class="language-csharp">
// PoolManager.cs의 일부
// 유니티에서 제공하는 Pool 사용
internal class Pool
{
    private GameObject _prefab;
    public IObjectPool&lt;GameObject&gt; _pool;
    private Transform _rootTransform;
    public Transform RootTransform
    {
        get =&gt; _rootTransform;
        set =&gt; _rootTransform = value;
    }

    public Pool(ObjectPreset preset, Transform parent)
    {
        _prefab = preset.prefab;
        RootTransform = parent;
        // Unity에서 제공하는 Pool
        // createFunc, OnGet, OnRelease, OnDestroy, 중복 반환 여부, 초기사이즈 , 최대사이즈
        _pool = new ObjectPool&lt;GameObject&gt;(OnCreate, OnGet, OnRelease, OnDestroy, true, preset.initialSize);
    }

    // 풀에 push하는건 사용이 끝나서 반환 하는것
    public void Push(GameObject go)
    {
        if (go.activeSelf)
            _pool.Release(go);
    }

    // 사용하기 위해서 Pool에서 가져옴
    public GameObject Pop()
    {
        return _pool.Get();
    }
}
            </code></pre>
            <pre><code class="language-csharp">
// PoolManager.cs의 일부
public class PoolManager
{
    private Dictionary&lt;string, Pool&gt; _pools =  new ();

    // 풀에 반환
    public bool Push(GameObject go)
    {
        // 해당 오브젝트를 위한 풀이 없으면 실패
        if (!_pools.ContainsKey(go.name))
            return false;

        _pools[go.name].Push(go);
        return true;
    }

    /// &lt;summary&gt;
    /// 프리셋 기반풀링 Pop
    /// &lt;/summary&gt;
    /// &lt;param name="objectPreset"&gt;&lt;/param&gt;
    /// &lt;param name="parent"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public GameObject Pop(ObjectPreset objectPreset, Transform parent = null)
    {
        if (!_pools.ContainsKey(objectPreset.prefab.name))
            CreatePool(objectPreset, parent);
        
        return  _pools[objectPreset.prefab.name].Pop();
    }

    private void CreatePool(ObjectPreset objectPreset, Transform parent = null)
    {
        Pool pool = new Pool(objectPreset, parent);
        _pools.Add(objectPreset.prefab.name, pool);
    }

    public void ResetPool()
    {
        _pools.Clear();
    }
}
            </code></pre>
            <pre><code class="language-csharp">
// ResourceManager.cs
public GameObject Instantiate(EObjectID key, Vector3 pos = default(Vector3), Transform parent = null)
{
  GameObject go = null;
  ObjectPreset preset = _sourceCatalog.GetObjPreset(key);
  if (preset == null)
  {
      Debug.LogError($"Failed to load preset : {key}");
      return null;
  }

  if (preset.poolable)
  {
      go = HeadManager.Pool.Pop(preset, parent);
      return go;
  }
            
  go = Object.Instantiate(preset.prefab, pos, Quaternion.identity, parent);
  go.name = preset.prefab.name;
    
  return go;
}

public void Destroy(GameObject go)
{
    if (go == null) return;
    
    if (HeadManager.Pool.Push(go)) return;
    Object.Destroy(go);
}
            </code></pre>
            <pre><code class="language-csharp">
// 능력 데이터를 저장하는 AbilityDef.cs의 일부
public class AbilityDef : ScriptableObject
{ 
    [Header("key")]
    public int id;
   
    [Header("UI")] 
    public Sprite icon;
    public string title;
    [TextArea] public string description;
    public int weight = 10;
    
    [Header("Value with level")]
    [Tooltip("먼저 생성된거 : 낮은 레벨, 나중에 생성된거 : 높은 레벨")]
    public List&lt;float&gt; Values = new List&lt;float&gt;();
   
    [Header("Target")] public EAbilityTarget target;
    [Header("Operator")] public EOperator op;
    
    private int _level = 0;
    public int AbilityLevel =&gt; _level;
    [SerializeField]private int _maxLevel = 990;
    public int MaxLevel =&gt; _maxLevel;
    protected Dictionary&lt;int, float&gt; abilityDict = new Dictionary&lt;int, float&gt;();
   
    private void OnEnable()
    {
        for (var i = 0; i &lt; Values.Count; i++)
        {
            abilityDict[i] = Values[i];
        }
    }
     
    /// &lt;summary&gt;
    /// 상한선에 도달했는지 확인
    /// &lt;/summary&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public bool IsCapped()
    {
        return _level &gt;= _maxLevel;
    }
     
    /// &lt;summary&gt;
    /// 기본 값에다 레벨에 따른 배율을 더해서 적용할 값 산출
    /// &lt;/summary&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public float GetNextValue()
    {
        return abilityDict[_level];
    }
     
    /// &lt;summary&gt;
    /// Description 작성될 문자열을 반환
    /// &lt;/summary&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public virtual string GetDescription()
    {
        return string.Format(description, GetNextValue());
    }
     
    /// &lt;summary&gt;
    /// Title영역에 작성될 문자열을 반환
    /// title {number} LV
    /// &lt;/summary&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public virtual string GetTitle()
    {
        string res = (_level + 1).ToString();
        if (_level == _maxLevel - 1)
            res = "MAX";
        
        return title +" "+ res + " LV";
    }
     
    /// &lt;summary>
    /// 실제 값 적용
    /// &lt;/summary&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public virtual float GetFinalValue()
    {
        // 캡이면 적용 안 함(원하면 다른 처리)
        if (_level &gt;= _maxLevel)
        {
            Debug.LogError("[AbilityDef] Max level ability selected");
            return 0; 
        }
        var val = GetNextValue();
        _level++;
        return val;
    }
}
            </code></pre>
          </details>
        </div>
        <br />
      </article>
    </section>

    <!-- Links -->
    <section>
      <h2>관련 링크</h2>
      <ul>
        <!--<li><a href="https://github.com/Garagekeeper/Guns_GermsAndSteel" target="_blank">GitHub Repository</a></li>-->
        <!--<li><a href="https://velog.io/@garage_keeper/series/isaac모작" target="_blank">기술 블로그</a></li>-->
      </ul>
    </section>
  </div>
  <hr />

  <div class="project-container">
    <h1 class="ptitle">2. 아이작 모작 프로젝트</h1>

    <!-- Overview -->
    <section>
      <h2>프로젝트 개요</h2>
      <p>The Binding of issac을 Unity에서 구현해보는 개인 프로젝트입니다.</p>
    </section>

    <!-- ref -->
    <section>
      <h2>사용 기술</h2>
      <ul>
        <li>Unity 3.5</li>
        <li>C#</li>
        <li>Addressible</li>
      </ul>
    </section>

    <!-- Roles -->
    <section>
      <h2>담당 역할</h2>
      <ul>
        <li>게임 클라이언트 전반 구조 설계 및 구현</li>
      </ul>
    </section>

    <!-- Video -->
    <section>
      <h2>플레이 영상</h2>
      <div class="video-wrapper">
        <iframe
          width="560"
          height="315"
          src="https://www.youtube.com/embed/X_B_yyo6mb8"
          title="Gameplay Video"
          allowfullscreen
        >
        </iframe>
      </div>
    </section>

    <!-- Core System -->
    <section>
      <h2>겪었던 문제와 해결 방안</h2>
      <article>
        <!--Problem 1-->
        <div class="Problem">
          <h3>1. 너무 많은 엔티티</h3>
          <ul>
            <li>
              <strong>문제</strong>
              <p>
                로그라이크 특성상 아이템 수가 많아질수록 개별 스크립트로는
                유지보수가 어려웠습니다.
              </p>
            </li>

            <li>
              <strong>선택</strong>
              <p>
                Data-Driven 구조를 도입해서 아이템의 정의를 외부 데이터(csv)로
                분리했습니다.
              </p>
            </li>

            <li>
              <strong>결과</strong>
              <ul>
                <li>아이템 추가 시 코드 수정 없이 확장 가능했습니다.</li>
                <li>밸런스 조정을 간편하게 할 수 있었습니다.</li>
                <li>데이터 기반 구조로 협업 용이</li>
              </ul>
            </li>
          </ul>
          <details class="code-sample">
            <summary>코드 예시 (클릭시 펼쳐짐)</summary>
            <pre><code class="language-csharp">
// 런타임에 파싱한 정적 데이터
[Serializable]
public class ItemData
{
    public int DataId;
    public string Name;
    public int CoolTime;
    public float DmgUp;
}

public class ItemDataLoader : ILoader&lt;int, ItemData&gt;
{
    public List&lt;ItemData&gt; items;

    public Dictionary&lt;int, ItemData&gt; MakeDict()
    {
        var dict = new Dictionary&lt;int, ItemData&gt;();
        foreach (var item in items)
            dict[item.DataId] = item;
        return dict;
    }
}
            </code></pre>
            <br />

            <pre><code class="language-csharp">
// 런타임에 template data로부터 생성된 아이템 인스턴스
public class Item
{
    public int TemplateId { get; }
    public int CurrentGage { get; private set; }

    private ItemData Template =&gt;
        Managers.Data.ItemDic[TemplateId];

    public Item(int itemId)
    {
        TemplateId = itemId;
        CurrentGage = Template.CoolTime;
    }
}
            </code></pre>
            <div>
              <img src="/assets/img/csvimage1.png" alt="csv file sample" />
            </div>
          </details>
        </div>
        <br />

        <!--Problem 2-->
        <div class="Problem">
          <h3>2. 랜덤 맵 생성</h3>
          <ul>
            <li>
              <strong>문제</strong>
              <p>
                사전에 모든 스테이지 요소를 배치하는 방식은 로그라이크의 핵심
                재미 요소인 랜덤성을 제공하기 어려웠습니다.
              </p>
            </li>

            <li>
              <strong>선택</strong>
              <p>
                런타임에 스테이지와 방(room)을 동적으로 생성하는 구조로
                변경했습니다. 스테이지는 격자(grid) 형태로 구성하고, BFS
                기반으로 전체 맵 형태를 결정했습니다. 각 방은 여러 타입의
                프리팹으로 관리하여 런타임에 인스턴스화했습니다.
              </p>
            </li>

            <li>
              <strong>결과</strong>
              <ul>
                <li>시드 기반의 랜덤 맵 생성 구현</li>
                <ul>
                  <li>
                    BFS를 사용해 시작 방에서 자연스럽게 확장되는 구조를 만들고,
                    스테이지가 지나치게 선형적이거나 복잡해지는 것을
                    방지했습니다.
                  </li>
                </ul>

                <li>원작과 유사한 로그라이크 플레이 경험 제공</li>
                <li>방 타입의 추가·제거가 쉬운 확장 가능한 구조 확보</li>
              </ul>
            </li>
          </ul>
          <details class="code-sample">
            <summary>코드 예시 (클릭시 펼쳐짐)</summary>
            <a
              href="https://github.com/Garagekeeper/Guns_GermsAndSteel"
              target="_blank"
              >Full Source</a
            >
            <br />
            <p><strong>BFS 기반 방 생성 로직</strong></p>
            <pre><code class="language-csharp">
public int GenerateStage()
{
  Queue&lt;RoomClass&gt; roomClassQueue = new();
  RoomClass rc;
  Rooms = new List&lt;RoomClass&gt;();
  int roomCnt = 0;

  s_roomGraph = new int[9, 9];

  //시작 위치
  s_roomGraph[4, 4] = 1;
  StartingRoom = new RoomClass(4, 4)
  {
    RoomType = ERoomType.Start
  };
  Rooms.Add(StartingRoom);

  //1.BFS를 통한 방 생성
  while (roomCnt &lt; Managers.Game.N)
  {
    roomClassQueue.Enqueue(Managers.Game.RNG.Choice(Rooms));

    while (roomClassQueue.Count != 0)
    {
      RoomClass front = roomClassQueue.Dequeue();
      //Right, Down, Left, Up
      int[] dx = { 0, 1, 0, -1 };
      int[] dy = { 1, 0, -1, 0 };

      for (int i = 0; i &lt; 4; i++)
      {
          if (roomCnt == Managers.Game.N) break;
          int nx = front.XPos + dx[i];
          int ny = front.YPos + dy[i];

          if (CanCreateRoom(nx, ny))
          {
              rc = new RoomClass(nx, ny);
              front._adjacencentRooms[i] = rc;
              rc._adjacencentRooms[(i + 2) % 4] = front;
              s_roomGraph[nx, ny] = 1;
              Rooms.Add(rc);
              roomCnt++;
              roomClassQueue.Enqueue(rc);
          }
      }
    }
  }
}
            </code></pre>
            <p><strong>뭉쳐진 형태의 스테이지 생성 방지</strong></p>
            <pre><code class="language-csharp">
public bool CanCreateRoom(int x, int y)
{
  if (x &lt; 0 || x &gt;= s_mapMaxXofRoomArray) return false;
  if (y &lt; 0 || y &gt;= s_mapMaxYofRoomArray) return false;
  // 이미 방이 있다면 넘어간다.
  if (s_roomGraph[x, y] == 1) return false;
  // 인접한 방이 2개 이상이면 방을 생성하지 않는다.
  if (CheckAdjacencyRoomCnt(x, y) &gt;= 2) return false;
  // 위조건을 만족해도 50보다 작아야 방을 생성
  if (!Managers.Game.RNG.Chance(50)) return false;
  return true;
}
            </code></pre>
            <p><strong>방(room) 인스턴스 생성</strong></p>
            <pre><code class="language-csharp">
public void GenerateRoom(RoomClass r, int index)
{
  //1.room 생성
  r.WorldCenterPos = CalcRoomsWorldPos(r);

  //room prfab 생성
  GameObject room = CreateRoomPrefab(r);

  // Select Random Map Collision
  int roomId = SelectRoomId(r);

  InitRoomClassField(r, room, roomId);

  //room 위치, 이름 조정
  SetRoomNameAndPos(r, room, index);

  SetObstacle(r);
  GenerateDoor(r);
}
            </code></pre>
          </details>
        </div>
        <br />

        <!--Problem 3-->
        <div class="Problem">
          <h3>3. 반복되는 단발적 사운드</h3>
          <ul>
            <li>
              <strong>문제</strong>
              <p>
                단발적인 사운드가 많은 게임이라 짧은 AudioSource 인스턴스가 다수
                생성·소멸되어 비효율적이었습니다.
              </p>
            </li>

            <li>
              <strong>선택</strong>
              <p>사운드 풀을 만들어 관리하였습니다.</p>
            </li>

            <li>
              <strong>결과</strong>
              <ul>
                <li>
                  Audio Source 생성/파괴의 횟수를 줄여 GC 최적화를 할 수
                  있었습니다.
                </li>
                <li>
                  사운드 재생 로직을 중앙화하여 확장성과 유지보수성
                  향상시켰습니다.
                </li>
              </ul>
            </li>
          </ul>

          <details class="code-sample">
            <summary>코드 예시 (클릭시 펼쳐짐)</summary>
            <a
              href="https://github.com/Garagekeeper/Guns_GermsAndSteel"
              target="_blank"
              >Full Source</a
            >
            <p><strong>SoundManager — AudioSource 풀 관리</strong></p>
            <pre><code class="language-csharp">
public class SoundManager
{
    public void ReturnSFXToPool(GameObject go)
    {
        // 큐에 넣을때는 active false로
        if (go == null) return;
        if (go.activeSelf == false) return;
        _sfxPool.Enqueue(go);
        go.SetActive(false);
    }

    public GameObject GetSFXFromPool()
    {
        // 큐에 남아있지 않으면 추가
        if (_sfxPool.Count == 0)
            AddNewSFXSource();

        // 큐에서 뽑아내서 반환
        GameObject sfx = _sfxPool.Dequeue();
        sfx.SetActive(true);

        return sfx;
    }

    // 오디오 클립 재생
    public GameObject PlaySFX(AudioClip clip, float volume = 1f, bool isLoop = false)
    {
        GameObject sfx = GetSFXFromPool();
        sfx.GetComponent&lt;SFXSource&gt;().Play(clip, volume, isLoop);
        return sfx;
    }
}
            </code></pre>
            <br />

            <p><strong>SFXSource — 재생 전용 컴포넌트</strong></p>
            <pre><code class="language-csharp">
public class SFXSource : MonoBehaviour
{
    private AudioSource _audioSource;
    private Coroutine _coroutine;

    private void Awake()
    {
        _audioSource = GetComponent&lt;AudioSource&gt;();
        _audioSource.playOnAwake = false;
        // 2D 라서 0
        _audioSource.spatialBlend = 0f;
    }

    public void Play(AudioClip clip, float volume = 1f, bool isLoop = false)
    {
        StopAllCoroutines();
        float delay = Random.Range(0f, 0.02f);
        _audioSource.Play();
        double offset = Random.Range(0f, 0.3f); // ±10ms 흔들기
        _audioSource.PlayScheduled(AudioSettings.dspTime  + offset);

        if (!isLoop)
            _coroutine = StartCoroutine(CDisableAfterPlay());
    }

    private IEnumerator CDisableAfterPlay()
    {
        yield return new WaitForSeconds(_audioSource.clip.length + 0.1f);
        Managers.Sound.ReturnSFXToPool(gameObject);
    }
}
            </code></pre>
          </details>
        </div>

        <br />
      </article>
    </section>

    <!-- Links -->
    <section>
      <h2>관련 링크</h2>
      <ul>
        <li>
          <a href="https://github.com/Garagekeeper/PEACEMAKER" target="_blank"
            >GitHub Repository</a
          >
        </li>
      </ul>
    </section>
  </div>
  <hr />

  <div class="project-container">
    <h1 class="ptitle">3. 2D 멀티플레이 플레포머제작 프로젝트</h1>

    <!-- Overview -->
    <section>
      <h2>프로젝트 개요</h2>
      <p>
        멀티 플레이가 가능한 2D 플랫포머 게임을 제작한 팀 프로젝트입니다. 단순히
        게임을 구현하는 데서 그치지 않고, 실시간 멀티플레이 환경에서의 서버 구조
        설계, 유저 제작 콘텐츠(맵 에디터) 공유, 클라이언트–서버–웹 서버 간 연동
        구조를 직접 설계하고 구현하는 것을 목표로 했습니다.
      </p>
    </section>

    <!-- ref -->
    <section>
      <h2>사용 기술</h2>
      <ul>
        <li>Unity</li>
        <li>C#</li>
        <li>Node.js</li>
        <li>MariaDB</li>
      </ul>
    </section>

    <!-- Roles -->
    <section>
      <h2>담당 역할</h2>
      <ul>
        <li>팀장</li>
        <li>게임 서버</li>
        <li>웹 서버</li>
        <li>맵 에디터</li>
        <p>
          기획, 일정 관리와 더불어 핵심 기술 파트(서버,맵 에디터,웹)을 직접
          담당했습니다.
        </p>
      </ul>
    </section>

    <!-- Video -->
    <section>
      <h2>플레이 영상</h2>
      <div class="video-wrapper">
        <iframe
          width="560"
          height="315"
          src="https://www.youtube.com/embed/wRBFfpuKVFw"
          title="Gameplay Video"
          allowfullscreen
        >
        </iframe>
        <iframe
          width="560"
          height="315"
          src="https://www.youtube.com/embed/TrkjBKc6YD8"
          title="Gameplay Video"
          allowfullscreen
        >
        </iframe>
      </div>
    </section>

    <!-- Core System -->
    <section>
      <h2>겪었던 문제와 해결 방안</h2>
      <article>
        <!--Problem 1-->
        <div class="Problem">
          <h3>1. 게임 서버를 어떻게 구현할 것인가</h3>
          <ul>
            <li>
              <strong>문제</strong>
              <p>
                멀티플레이 게임을 위한 서버 구조 자체가 가장 큰 난제였습니다.
                엔진이나 외부 프레임워크를 사용하면 빠르게 구현할 수 있었지만,
                네트워크 흐름과 서버 동작을 정확히 이해하기 어렵다는 한계가
                있었습니다.
              </p>
            </li>

            <li>
              <strong>선택</strong>
              <ui>
                <li>
                  엔진 의존적인 서버 대신, TCP / UDP 소켓 기반의 게임 서버를
                  처음부터 직접 구현했습니다.
                </li>
                <li>
                  인터넷을 참고해, 패킷의 직렬화와 역직렬화를 포함시켰습니다.
                </li>
                <li>
                  패킷 ID를 기준으로 처리 함수를 매핑하는 Packet Dispatcher
                  구조를 도입했습니다.
                </li>
                <li>
                  서버가 권한을 가지고 클라이언트들에게 뿌리는 방식을
                  선택했습니다.
                </li>
              </ui>
            </li>

            <li>
              <strong>결과</strong>
              <ul>
                <li>패킷 ID → 처리 함수 매핑 구조로 확장성 확보</li>
                <li>서버 동작 흐름에 대한 명확한 이해 확보</li>
              </ul>
              <p>서버 구조를 직접 설계하고 구현한 경험을 얻을 수 있었습니다</p>
            </li>
          </ul>
          <details class="code-sample">
            <summary>코드 예시 (클릭시 펼쳐짐)</summary>
            <pre><code class="language-csharp">
//Packet Dispatcher
packetHandler = new Dictionary&lt;int, PacketHandler&gt;()
{
    { (int)ClientPackets.TCPConnenctinCheckReceived, serverHandle.TCPConnenctinCheckReceived },
    { (int)ClientPackets.udpTestReceive, serverHandle.UDPTestReceive },
    { (int)ClientPackets.playerMovement, serverHandle.PlayerMovement },
    { (int)ClientPackets.playerShootBullet, serverHandle.PlayerBullet },
    { (int)ClientPackets.playerShootGrenade, serverHandle.PlayerGrenade },
    { (int)ClientPackets.playerStartVacuume, serverHandle.PlayerStartVaccume },
    { (int)ClientPackets.playerEndVacuume, serverHandle.PlayerEndVaccume },
    { (int)ClientPackets.ItemCollide, serverHandle.ItemCollide },
    { (int)ClientPackets.readyToStartGame, serverHandle.ReadyToStartGame},
    { (int)ClientPackets.playerJump, serverHandle.PlayerJump },
    { (int)ClientPackets.playerRopeMove, serverHandle.PlayerRopeMove },
    { (int)ClientPackets.goToNextPortal, serverHandle.GoToNextPortal },
    { (int)ClientPackets.readyToRestart, serverHandle.ReadyToRestartGame },
};
            </code></pre>
            <br />
            <pre><code class="language-csharp">
// Server Send packet example
public void SpawnProjectile(Projectile _projectile, int _thrownByplayer)
  {
      using (Packet _packet = new Packet((int)ServerPackets.spawnProjectile))
      {
          int _cnt = server.clients[_thrownByplayer].player.GrenadeCount;
          if (_cnt &gt; 0)
          {
              _packet.Write(_projectile.id);
              _packet.Write(_projectile.transform.localPosition);
              _packet.Write(_thrownByplayer);
              _packet.Write(server.clients[_thrownByplayer].player.GrenadeCount);
              sendTCPDataToAllInRoom(server.clients[_thrownByplayer].roomId, _packet);
          }
      }
  }
            </code></pre>

            <pre><code class = "language-csharp">
// Server Send packet example
public void SendData(Packet _packet)
  {
      try
      {
          if (socket != null)
          {
              stream.BeginWrite(_packet.ToArray(), 0, _packet.Length(), null, null);
          }
      }
      catch (Exception _ex)
      {
          Debug.Log($"Error Sending data to Player{id} via TCP:{_ex}");
      }
  }
    </code></pre>
            <pre><code class="language-csharp">
    // 패킷 직렬화
    /// &lt;summary&gt;Adds a byte to the packet.&lt;/summary&gt;
    /// &lt;param name=&quot;_value&quot;&gt;The byte to add.&lt;/param&gt;
    public void Write(byte _value)
    {
        buffer.Add(_value);
    }
    /// &lt;summary&gt;Adds an int to the packet.&lt;/summary&gt;
    /// &lt;param name=&quot;_value&quot;&gt;The int to add.&lt;/param&gt;
    public void Write(int _value)
    {
        buffer.AddRange(BitConverter.GetBytes(_value));
    }
    public void Write(float _value)
    {
        buffer.AddRange(BitConverter.GetBytes(_value));
    }
    /// &lt;summary&gt;Adds a string to the packet.&lt;/summary&gt;
    /// &lt;param name=&quot;_value&quot;&gt;The string to add.&lt;/param&gt;
    public void Write(string _value)
    {
        Write(_value.Length); // Add the length of the string to the packet
        buffer.AddRange(Encoding.ASCII.GetBytes(_value)); // Add the string itself
    }
    </code></pre>
            <pre><code class="language-csharp">
// 패킷 역직렬화
public byte ReadByte(bool _moveReadPos = true)
    {
        if (buffer.Count &gt; readPos)
        {
            // If there are unread bytes
            byte _value = readableBuffer[readPos]; // Get the byte at readPos&apos; position
            if (_moveReadPos)
            {
                // If _moveReadPos is true
                readPos += 1; // Increase readPos by 1
            }
            return _value; // Return the byte
        }
        else
        {
            throw new Exception(&quot;Could not read value of type &apos;byte&apos;!&quot;);
        }
    }

    /// &lt;summary&gt;Reads an int from the packet.&lt;/summary&gt;
    /// &lt;param name=&quot;_moveReadPos&quot;&gt;Whether or not to move the buffer&apos;s read position.&lt;/param&gt;
    public int ReadInt(bool _moveReadPos = true)
    {
        if (buffer.Count &gt; readPos)
        {
            // If there are unread bytes
            int _value = BitConverter.ToInt32(readableBuffer, readPos); // Convert the bytes to an int
            if (_moveReadPos)
            {
                // If _moveReadPos is true
                readPos += 4; // Increase readPos by 4
            }
            return _value; // Return the int
        }
        else
        {
            throw new Exception(&quot;Could not read value of type &apos;int&apos;!&quot;);
        }
    }

    /// &lt;summary&gt;Reads a float from the packet.&lt;/summary&gt;
    /// &lt;param name=&quot;_moveReadPos&quot;&gt;Whether or not to move the buffer&apos;s read position.&lt;/param&gt;
    public float ReadFloat(bool _moveReadPos = true)
    {
        if (buffer.Count &gt; readPos)
        {
            // If there are unread bytes
            float _value = BitConverter.ToSingle(readableBuffer, readPos); // Convert the bytes to a float
            if (_moveReadPos)
            {
                // If _moveReadPos is true
                readPos += 4; // Increase readPos by 4
            }
            return _value; // Return the float
        }
        else
        {
            throw new Exception(&quot;Could not read value of type &apos;float&apos;!&quot;);
        }
    }

    /// &lt;summary&gt;Reads a string from the packet.&lt;/summary&gt;
    /// &lt;param name=&quot;_moveReadPos&quot;&gt;Whether or not to move the buffer&apos;s read position.&lt;/param&gt;
    public string ReadString(bool _moveReadPos = true)
    {
        try
        {
            int _length = ReadInt(); // Get the length of the string
            string _value = Encoding.ASCII.GetString(readableBuffer, readPos, _length); // Convert the bytes to a string
            if (_moveReadPos &amp;&amp; _value.Length &gt; 0)
            {
                // If _moveReadPos is true string is not empty
                readPos += _length; // Increase readPos by the length of the string
            }
            return _value; // Return the string
        }
        catch
        {
            throw new Exception(&quot;Could not read value of type &apos;string&apos;!&quot;);
        }
    }

            </code></pre>

            <br />
          </details>
        </div>
        <br />
        <!--Problem 2-->
        <div class="Problem">
          <h3>2.맵 에디터 공유</h3>
          <ul>
            <li>
              <strong>문제</strong>
              <p>
                맵 에디터를 이용해서 제작한 맵을 공유하는 기능이 필요헀습니다
              </p>
            </li>

            <li>
              <strong>선택</strong>
              <p>
                맵의 정보를 json형태로 저장해 공유할 수 있도록 nodejs, mariadb를
                사용한 웹서버를 만들었습니다.
              </p>
            </li>

            <li>
              <strong>결과</strong>
              <p>Api를 통해 맵을 웹서버에 등록, 조회할 수 있었습니다.</p>
            </li>
          </ul>
          <details class="code-sample">
            <summary>코드 예시 (클릭시 펼쳐짐)</summary>
            <pre><code class="language-csharp">
public void Share(GameObject _infoObject)
{
  var _mapName = _infoObject.transform.GetChild(0).GetComponent&lt;InputField&gt;();
  Save(_mapName);

  if(File.Exists(fullFilePath + &quot;.json&quot;) == false)
  {
      Debug.LogError(&quot;Load failed. There is no file.&quot;);
      return;
  }
  string map_info = File.ReadAllText(fullFilePath + &quot;.json&quot;);

  var map_tag = _infoObject.transform.GetChild(1).GetComponent&lt;InputField&gt;().text;
  var map_difficulty = _infoObject.transform.GetChild(2).GetComponent&lt;InputField&gt;().text;
 
  SaveDataClass _forSend = new SaveDataClass();
  _forSend.map_info = map_info;
  _forSend.map_tag = map_tag;
  _forSend.map_difficulty = Int32.Parse(map_difficulty);
  _forSend.map_maker = UserDataManager.instance.username;

  string _forSendJson = JsonUtility.ToJson(_forSend);

  StartCoroutine(MapShareProcess(_result =&gt;
  {
      if (_result)
      {
          Debug.Log(&quot;SAVE&quot;);
          BackToMain();
      }
  }));
}

IEnumerator MapShareProcess(Action&lt;bool&gt; ResultHandler)
{
  using (UnityWebRequest request = UnityWebRequest.Put(UserDataManager.instance.apiUrl + &quot;api/map/apply&quot;, _forSendJson))
  {
    byte[] jsonToSend = new System.Text.UTF8Encoding().GetBytes(_forSendJson);
    request.SetRequestHeader(&quot;Content-Type&quot;, &quot;application/json&quot;);

    request.uploadHandler.Dispose();

    request.uploadHandler = new UploadHandlerRaw(jsonToSend);
    request.downloadHandler = new DownloadHandlerBuffer();

    yield return request.SendWebRequest();
    string _result = request.downloadHandler.text;

    if (request.error != null)
    {
      Debug.Log(request.error);
    }
    else
    {
      Debug.Log(_result);
      ResultHandler(true);
    }

    request.uploadHandler.Dispose();
    request.downloadHandler.Dispose();
    request.Dispose();
  }
}
            </code></pre>
            <pre><code class="language-javascript">
  router.put(&quot;/apply&quot;, map.applyMap);

  exports.applyMap = async (req, res) =&gt; {
  if (!req.body) {
    res.status(400).send({
      message: &quot;req.body can not be empty!&quot;,
    });
  } else {
    if (req.body.map_maker) {
      const temp = await data.findUserById(req.body.map_maker);
      if(temp.ok){
          console.log(req.body.map_maker);
      } else {
        res.status(400).send({
          message: &quot;applyMap err&quot;,
        });
        return;
      }
    }
    map.createMap(req.body, (err, result) =&gt; {
      if (err) {
        res.status(400).send({
          message: &quot;applyMap err&quot;,
        });
      } else {
        res.send({
          map_id: result.map_id,
        });
      }
    });
  }
};
            </code></pre>
            <br />
          </details>
        </div>
        <br />
      </article>
    </section>

    <!-- Links -->
    <section>
      <h2>관련 링크</h2>
      <ul>
        <li>
          <a
            href="https://github.com/orgs/Team-Pickles/repositories"
            target="_blank"
            >GitHub Repository</a
          >
        </li>
        <li>
          <a
            href="https://eight-galleon-dd7.notion.site/BASEMENT-CLEANER-ce6659eacfc14d228811e20e067a913d"
            target="_blank"
            >조금 더 자세한 소개</a
          >
        </li>
      </ul>
    </section>
  </div>
  <hr />
</main>

<!--mermaid-->
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script>
  mermaid.initialize({ startOnLoad: true, theme: "dark" });
</script>

<!--Highlight.js-->
<link
  rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/vs2015.min.css"
/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/csharp.min.js"></script>
<script>
  hljs.highlightAll();
</script>
